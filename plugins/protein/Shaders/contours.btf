<?xml version="1.0" encoding="utf-8"?>
<btf type="MegaMolGLSLShader" version="1.0" namespace="contours">
    <include file="protein"/>
      <shader name="vertex">
        <snippet type="version">330</snippet>
        <snippet type="string">
        <!--
            layout (location = 0) in vec2 aPos;
            layout (location = 1) in vec2 aTexCoords;

            out vec2 TexCoords;

            void main()
            {
                TexCoords = aTexCoords;
                gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0); 
            }  
            -->
            </snippet>
        </shader>

      <shader name="passThrough">
        <snippet type="version">330</snippet>
        <snippet type="string">
        <!--
            out vec4 FragColor;
            in vec2 TexCoords;
            uniform sampler2D screenTexture;

            void main()
            { 
                vec4 color = texelFetch(screenTexture, ivec2(gl_FragCoord.xy), 0);
                if(color == vec4(0.0))
                    discard;
                FragColor = color;
            }
            -->
            </snippet>
        </shader>
      <shader name="normalizePositions">
        <snippet type="version">330</snippet>
        <snippet type="string">
        <!--
            out vec4 FragColor;
            in vec2 TexCoords;
            uniform sampler2D positionTexture;
            uniform sampler2D depthTexture;
            uniform sampler2D heightTexture;
            uniform sampler2D widthTexture;
            uniform int level_max;

            void main()
            { 
                vec4 position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy), 0);
                if(position == vec4(0.0))
                    discard;
                vec2 depth = texelFetch(depthTexture, ivec2(0,0), level_max - 1).xy;
                vec2 height = texelFetch(heightTexture, ivec2(0,0), level_max - 1).xy;
                vec2 width = texelFetch(widthTexture, ivec2(0,0), level_max - 1).xy;
                //TODO: Do this with the real mins and max (fix pyramids)

                // vec3 mins = vec3(width.y, height.y, depth.y);
                // vec3 maxs = vec3(width.x, height.x, depth.x);

                vec3 mins = vec3(-30.0, -30.0, -158.0);
                vec3 maxs = vec3(30.0, 30.0, -120.0);
                vec3 color= (position.xyz - mins) / (maxs-mins);
                FragColor = vec4(color, 1.0);
            }

            -->
            </snippet>
        </shader>

        <namespace name="shading">
        <shader name="fragment">
          <snippet type="version">330</snippet>
          <snippet type="string">
            <!--
            out vec4 FragColor;
            in vec2 TexCoords;

            uniform sampler2D normalTexture;
            uniform sampler2D positionTexture;
            uniform sampler2D diffuseTexture;

            //parameter
            uniform int radius;
            uniform float neighbourThreshold; //percentage s in original  SC paper //  in original paper 0.2
            uniform float intensityDiffThreshold; //threshold d in original SC paper // in original paper 0.25
            uniform bool medianFilter;
            uniform bool circularNeighborhood;

            void main()
            {
                //total number of points according to radius [gauss circle problem]
                // int total;
                // if(radius == 1)
                //     total = 5;
                // else if(radius == 2)
                //     total = 13;
                // else if(radius == 3)
                //     total = 29;
                // else if(radius == 4)
                //     total = 49;
                // else if(radius == 5)
                //     total = 81;
                // else if(radius == 6)
                //     total = 113;
                // else if(radius == 7)
                //     total = 149;
                // else if(radius == 8)
                //     total = 197;
                // else if(radius == 9)
                //     total = 253;
                // else if(radius == 10)
                //     total = 317;

                vec3 normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy), 0).rgb;  
                if(normal == vec3(0.0)){
                    discard;
                }
                vec3 position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy), 0).rgb;
                vec3 lightdir = normalize(vec3(0.0, 0.0, 0.0) - position); 
                float col = dot(normal, lightdir);

                int darker = 0; //How many values are darker than the current pixel?
                float maxIntensity = col;
                
                float filterValues[100]; //Use biggest number as OpenGL does not allow variable sized arrays
                filterValues[0] = col;    //collects all values for median filtering. 
                                            //Incoming values are grayscale therefore r component is sufficient

                 
                // Loop over square with size radius * radius (use symmetry so only 1/4 needs to be tested).
                // Discard all points that are not part of the circle
                // Collect data and save all intensities to filterValues
                int idx = 1;
                int total = 1;
                vec3 cur_normal;
                vec3 cur_position;
                vec3 cur_lightdir;
                float cur;
                for(int x = 0; x <= radius; x++){
                    for(int y = 0; y <= radius; y++){
                        if(x == 0 && y == 0)
                            continue;
                        else if(circularNeighborhood && x*x + y*y > radius * radius){
                            continue;
                        }
                        else{
                            ++total;
                            cur_normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy) + ivec2(x,y), 0).rgb;
                            cur_position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(x,y), 0).rgb;
                            cur_lightdir = normalize(-cur_position);
                            cur = dot(cur_normal, cur_lightdir);
                            if(cur <= col)
                                ++darker;
                            if(cur > maxIntensity)
                                maxIntensity = cur;
                            filterValues[idx] = cur;
                            idx++;

                            if(x != 0){
                                ++total;
                                cur_normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy) + ivec2(-x,y), 0).rgb;
                                cur_position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(-x,y), 0).rgb;
                                cur_lightdir = normalize(-cur_position);
                                cur = dot(cur_normal, cur_lightdir);
                                if(cur <= col)
                                    ++darker;
                                if(cur > maxIntensity)
                                    maxIntensity = cur;
                                filterValues[idx] = cur;
                                idx++;
                                
                                if(y != 0){
                                    ++total;
                                    cur_normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy) + ivec2(-x,-y), 0).rgb;
                                    cur_position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(-x,-y), 0).rgb;
                                    cur_lightdir = normalize(-cur_position);
                                    cur = dot(cur_normal, cur_lightdir);
                                    if(cur <= col)
                                        ++darker;
                                    if(cur > maxIntensity)
                                        maxIntensity = cur;
                                    filterValues[idx] = cur;
                                    idx++;
                                }
                            }

                            if(y!= 0){
                                ++total;
                                cur_normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy) + ivec2(x,-y), 0).rgb;
                                cur_position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(x,-y), 0).rgb;
                                cur_lightdir = normalize(-cur_position);
                                cur = dot(cur_normal, cur_lightdir);
                                if(cur <= col)
                                    ++darker;
                                if(cur > maxIntensity)
                                    maxIntensity = cur;
                                filterValues[idx] = cur;
                                idx++;
                            }

                        }
                    }
                }
                if(darker > neighbourThreshold * total){
                    discard;
                }
                if(maxIntensity - col <= intensityDiffThreshold){
                    discard;
                }

                // //Median filtering
                if(medianFilter){
                    for(int n = total-1; n > 0; n = n - 1){
                        for(int i = 0; i < n; ++i){
                            float minimum = min(filterValues[i], filterValues[i+1]);
                            filterValues[i+1] = max(filterValues[i], filterValues[i+1]);
                            filterValues[i] = minimum;
                        }
                    }
                    // assign col to the median
                    col = filterValues[int(floor(total * 1.0 / 2.0))];
                }

                col = 1.0 - col; //invert color because background is dark

                FragColor = vec4(col, col, col, 1.0);
            }
          -->
        </snippet>
      </shader>
      </namespace>

        <namespace name="curvature">
        <shader name="evans">
          <snippet type="version">330</snippet>
          <snippet type="string">
            <!--


            out vec4 fragCurvature;

            uniform sampler2D tex_fragPosition;
            uniform sampler2D tex_fragNormal;


            void main() {
                vec4 passPosition_view = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy), 0);
                vec4 passNormal_view = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy), 0);
                if(passPosition_view == vec4(0.0))
                    discard;

                vec3 n = normalize(passNormal_view.xyz);

                vec3 pixelPositionLeft = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0).xyz;
                vec3 pixelPositionTop = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;
                vec3 pixelPositionRight = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;
                vec3 pixelPositionBottom = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,1)), 0).xyz;

                // Compute curvature
                vec3 dx = dFdx(n) / length(pixelPositionLeft - pixelPositionRight); // Das ist zur Normalisierung, da man nicht weiß wie weit die einzelnen Pixel im view space tatsächlich auseinander liegen und man schlussendlich in jedem fragemnt shader Lauf gleiche Abstände haben möchte
                vec3 dy = dFdy(n) / length(pixelPositionTop - pixelPositionBottom);
                vec3 xneg = n - dx;//Das hier sind dann quasi die neuen ein bisschen verschobenen Normalen aber äquivalente Abstände für alle fragment shader läufe
                vec3 xpos = n + dx;
                vec3 yneg = n - dy;
                vec3 ypos = n + dy;
                float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x);

                fragCurvature = vec4(vec3(curvature), 1.0);
            }
            -->
            </snippet>
        </shader>

        <shader name="mean">
          <snippet type="version">330</snippet>
          <snippet type="string">
            <!--


            out vec4 fragCurvature;

            uniform sampler2D tex_fragPosition;
            uniform sampler2D tex_fragNormal;


            void main() {
                vec4 passPosition_view = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy), 0);
                vec4 passNormal_view = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy), 0);
                if(passPosition_view == vec4(0.0))
                    discard;

                vec3 n = normalize(passNormal_view.xyz);

                vec3 pLeft = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0).xyz;
                vec3 pTop = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;
                vec3 pRight = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;
                vec3 pBottom = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,1)), 0).xyz;

                vec3 dx = dFdx(n) / length(pLeft - pRight); // Das ist zur Normalisierung, da man nicht weiß wie weit die einzelnen Pixel im view space tatsächlich auseinander liegen und man schlussendlich in jedem fragemnt shader Lauf gleiche Abstände haben möchte
                vec3 dy = dFdy(n) / length(pTop - pBottom);
                
                float curvature = (-(dx.x + dy.y)/n.z + (n.x * dx.z + n.y * dy.z) / (n.z * n.z)) / -2;

                fragCurvature = vec4(vec3(curvature), 1.0);
            }
            -->
            </snippet>
        </shader>

        <shader name="normal">
          <snippet type="version">330</snippet>
          <snippet type="string">
            <!--


            out vec4 fragCurvature;

            uniform sampler2D tex_fragPosition;
            uniform sampler2D tex_fragNormal;


            void main() {
                vec4 passPosition_view = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy), 0);
                vec4 passNormal_view = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy), 0);
                if(passPosition_view == vec4(0.0))
                    discard;

                vec3 p = passPosition_view.xyz;
                vec3 n = normalize(passNormal_view.xyz);

                vec3 pLeft = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0).xyz;
                vec3 pTop = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;
                vec3 pRight = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;
                vec3 pBottom = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,1)), 0).xyz;

                // Compute curvature for all "edges" in the 4-neighborhood
                float curvatureLeft = 2 * dot(n, p - pLeft) / (length(p-pLeft) * length(p-pLeft));
                float curvatureTop = 2 * dot(n, p - pTop) / (length(pTop - p) * length(pTop - p));
                float curvatureRight = 2 * dot(n, p - pRight) / (length(pRight - p) * length(pRight - p));
                float curvatureBottom = 2 * dot(n, p - pBottom) / (length(pBottom - p) * length(pBottom - p));

                float curvature = (curvatureLeft + curvatureTop + curvatureRight + curvatureBottom) / 4;

                fragCurvature = vec4(vec3(curvature), 1.0);
            }
            -->
            </snippet>
        </shader>
        
        <shader name="fragment">
          <snippet type="version">330</snippet>
          <snippet type="string">
            <!--
            out vec4 fragCurvature;

            uniform sampler2D tex_fragPosition;
            uniform sampler2D tex_fragCurvature;
            uniform sampler2D tex_fragNormal;

            vec4 showZerocrossing(float curvature, float curvatureDxy) {
                if(abs(curvature) <= 0.01 * curvatureDxy) {
                    return vec4(0);
                }
                return vec4(1);
            }

            void main() {
                vec3 pixelPosition = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy), 0).xyz;
                vec3 pixelNormal = normalize(texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy), 0).xyz);
                vec4 curvature = texelFetch(tex_fragCurvature, ivec2(gl_FragCoord.xy), 0);

                // if (curvature.xyz == vec3(1, 0, 0)) { // "Maske"
                //     fragCurvature=vec4(1);
                // }

                float f = 1.0;//0.01;
                float scaledCurvature = curvature.x * f;

                // TODO: use pixel 3D locations to calculate the derivative. Also smooth the result -> pull-push
                vec3 pixelPositionLeft = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0).xyz;
                vec3 pixelPositionTop = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;
                vec3 pixelPositionRight = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;
                vec3 pixelPositionBottom = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,1)), 0).xyz;

                float curvatureDx = dFdx(scaledCurvature); // / length(pixelPositionLeft - pixelPositionRight);
                float curvatureDy = dFdy(scaledCurvature); // / length(pixelPositionTop - pixelPositionBottom);
                vec2 curvatureDirection = (vec2(curvatureDx, curvatureDy));

                // create local coordinate system at the pixel position
                vec3 h = normalize(vec3(-1));
                vec3 U = cross(pixelNormal, h);
                vec3 V = cross(h, U);

                // project the view vector into the local system
                vec3 v = normalize(-pixelPosition);
                vec2 vProjected = vec2(dot(U,v), dot (V,v));

                float isSuggestiveContour = sign(dot(vProjected, curvatureDirection));

                if (scaledCurvature >= 0) {
                    fragCurvature = vec4(1) - vec4(scaledCurvature, 0, 0, 0);
                } else {
                    fragCurvature = vec4(1) - vec4(0, -scaledCurvature, 0, 0);
                }

                if(isSuggestiveContour > 0) {
                    fragCurvature *= showZerocrossing(scaledCurvature, length(curvatureDirection));
                }

            }
          -->
        </snippet>
      </shader>
      </namespace>
</btf>