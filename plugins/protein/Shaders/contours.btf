<?xml version="1.0" encoding="utf-8"?>
<btf type="MegaMolGLSLShader" version="1.0" namespace="contours">
    <include file="protein"/>
      <shader name="vertex">
        <snippet type="version">330</snippet>
        <snippet type="string">
        <!--
            layout (location = 0) in vec2 aPos;
            layout (location = 1) in vec2 aTexCoords;

            out vec2 TexCoords;

            void main()
            {
                TexCoords = aTexCoords;
                gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0); 
            }  
            -->
            </snippet>
        </shader>

      <shader name="passThrough">
        <snippet type="version">330</snippet>
        <snippet type="string">
        <!--
            out vec4 FragColor;
            in vec2 TexCoords;
            uniform sampler2D screenTexture;

            void main()
            { 
                vec4 color = texelFetch(screenTexture, ivec2(gl_FragCoord.xy), 0);
                if(color == vec4(0.0))
                    discard;
                FragColor = color;
            }
            -->
            </snippet>
        </shader>
      <shader name="normalizePositions">
        <snippet type="version">330</snippet>
        <snippet type="string">
        <!--
            out vec4 FragColor;
            in vec2 TexCoords;
            uniform sampler2D positionTexture;
            uniform sampler2D depthTexture;
            uniform sampler2D heightTexture;
            uniform sampler2D widthTexture;
            uniform int level_max;

            void main()
            { 
                vec4 position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy), 0);
                vec4 position_l = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(-1,0), 0);
                if(position == vec4(0.0))
                    discard;
                vec2 depth = texelFetch(depthTexture, ivec2(0,0), level_max - 1).xy;
                vec2 height = texelFetch(heightTexture, ivec2(0,0), level_max - 1).xy;
                vec2 width = texelFetch(widthTexture, ivec2(0,0), level_max - 1).xy;

                vec3 mins = vec3(width.y, height.y, depth.y);
                vec3 maxs = vec3(width.x, height.x, depth.x);

                vec3 intensity;
                intensity = (position.xyz - mins) / (maxs - mins);
                FragColor = vec4(intensity, 1.0);
            }

            -->
            </snippet>
        </shader>

        <namespace name="contours">
        <shader name="SC">
          <snippet type="version">330</snippet>
          <snippet type="string">
            <!--
            out vec4 FragColor;
            in vec2 TexCoords;

            uniform sampler2D normalTexture;
            uniform sampler2D positionTexture;

            //parameter
            uniform int radius;
            uniform float neighbourThreshold; //percentage s in original  SC paper //  in original paper 0.2
            uniform float intensityDiffThreshold; //threshold d in original SC paper // in original paper 0.25
            uniform bool medianFilter;
            uniform bool circularNeighborhood;
            uniform bool orthogonal_view;

            void main()
            {
                //total number of points according to radius [gauss circle problem]
                // int total;
                // if(radius == 1)
                //     total = 5;
                // else if(radius == 2)
                //     total = 13;
                // else if(radius == 3)
                //     total = 29;
                // else if(radius == 4)
                //     total = 49;
                // else if(radius == 5)
                //     total = 81;
                // else if(radius == 6)
                //     total = 113;
                // else if(radius == 7)
                //     total = 149;
                // else if(radius == 8)
                //     total = 197;
                // else if(radius == 9)
                //     total = 253;
                // else if(radius == 10)
                //     total = 317;

                vec3 normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy), 0).rgb;  
                if(normal == vec3(0.0)){
                    discard;
                }
                vec3 position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy), 0).rgb;
                vec3 lightdir;
                if(orthogonal_view)
                    lightdir =vec3(0.0, 0.0, 1.0); 
                else
                    lightdir = normalize(vec3(0.0, 0.0, 0.0) - position); 
                float col = dot(normal, lightdir);

                int darker = 0; //How many values are darker than the current pixel?
                float maxIntensity = col;
                
                float filterValues[100]; //Use biggest number as OpenGL does not allow variable sized arrays
                filterValues[0] = col;    //collects all values for median filtering. 
                                            //Incoming values are grayscale therefore r component is sufficient

                 
                // Loop over square with size radius * radius (use symmetry so only 1/4 needs to be tested).
                // Discard all points that are not part of the circle
                // Collect data and save all intensities to filterValues
                int idx = 1;
                int total = 1;
                vec3 cur_normal;
                vec3 cur_position;
                float cur;
                for(int x = 0; x <= radius; x++){
                    for(int y = 0; y <= radius; y++){
                        if(x == 0 && y == 0)
                            continue;
                        else if(circularNeighborhood && x*x + y*y > radius * radius){
                            continue;
                        }
                        else{
                            ++total;
                            cur_normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy) + ivec2(x,y), 0).rgb;
                            cur_position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(x,y), 0).rgb;
                            if(!orthogonal_view)
                                lightdir = normalize(-cur_position);
                            cur = dot(cur_normal, lightdir);
                            if(cur <= col)
                                ++darker;
                            if(cur > maxIntensity)
                                maxIntensity = cur;
                            filterValues[idx] = cur;
                            idx++;

                            if(x != 0){
                                ++total;
                                cur_normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy) + ivec2(-x,y), 0).rgb;
                                cur_position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(-x,y), 0).rgb;
                                if(!orthogonal_view)
                                    lightdir = normalize(-cur_position);
                                cur = dot(cur_normal, lightdir);
                                if(cur <= col)
                                    ++darker;
                                if(cur > maxIntensity)
                                    maxIntensity = cur;
                                filterValues[idx] = cur;
                                idx++;
                                
                                if(y != 0){
                                    ++total;
                                    cur_normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy) + ivec2(-x,-y), 0).rgb;
                                    cur_position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(-x,-y), 0).rgb;
                                    if(!orthogonal_view)
                                        lightdir = normalize(-cur_position);
                                    cur = dot(cur_normal, lightdir);
                                    if(cur <= col)
                                        ++darker;
                                    if(cur > maxIntensity)
                                        maxIntensity = cur;
                                    filterValues[idx] = cur;
                                    idx++;
                                }
                            }

                            if(y!= 0){
                                ++total;
                                cur_normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy) + ivec2(x,-y), 0).rgb;
                                cur_position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(x,-y), 0).rgb;
                                if(!orthogonal_view)
                                    lightdir = normalize(-cur_position);
                                cur = dot(cur_normal, lightdir);
                                if(cur <= col)
                                    ++darker;
                                if(cur > maxIntensity)
                                    maxIntensity = cur;
                                filterValues[idx] = cur;
                                idx++;
                            }

                        }
                    }
                }
                if(darker > neighbourThreshold * total){
                    discard;
                }
                if(maxIntensity - col <= intensityDiffThreshold){
                    discard;
                }

                // //Median filtering
                if(medianFilter){
                    for(int n = total-1; n > 0; n = n - 1){
                        for(int i = 0; i < n; ++i){
                            float minimum = min(filterValues[i], filterValues[i+1]);
                            filterValues[i+1] = max(filterValues[i], filterValues[i+1]);
                            filterValues[i] = minimum;
                        }
                    }
                    // assign col to the median
                    col = filterValues[int(floor(total * 1.0 / 2.0))];
                }

                col = 1.0 - col; //invert color because background is dark

                FragColor = vec4(col, col, col, 1.0);
            }
          -->
        </snippet>
      </shader>

        <shader name="SC_Curvature">
          <snippet type="version">330</snippet>
          <snippet type="string">
            <!--
            //This is not really working. When the curvature is high for an object, the values inside the sphere are varying strongly such that the intensityDiffThreshold does not catch them anymore.
            out vec4 FragColor;
            in vec2 TexCoords;

            uniform sampler2D normalTexture;
            uniform sampler2D positionTexture;
            uniform sampler2D curvatureTexture;

            //parameter
            uniform int radius;
            uniform float neighbourThreshold; //percentage s in original  SC paper //  in original paper 0.2
            uniform float intensityDiffThreshold; //threshold d in original SC paper // in original paper 0.25
            uniform float cutOff;
            uniform bool medianFilter;
            uniform bool circularNeighborhood;
            uniform bool orthogonal_view;

            void main()
            {
                vec3 normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy), 0).rgb;  
                if(normal == vec3(0.0)){
                    discard;
                }
                vec3 position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy), 0).rgb;
                float curvature = texelFetch(curvatureTexture, ivec2(gl_FragCoord.xy), 0).r;
                // vec3 lightdir = normalize(vec3(0.0, 0.0, 0.0) - position); 
                vec3 lightdir =vec3(0.0, 0.0, 1.0); 
                float col = dot(normal, lightdir);
                col /= sqrt(cutOff * abs(curvature) * (2 - cutOff * abs(curvature)));

                int darker = 0; //How many values are darker than the current pixel?
                float maxIntensity = col;
                
                float filterValues[100]; //Use biggest number as OpenGL does not allow variable sized arrays
                filterValues[0] = col;    //collects all values for median filtering. 
                                            //Incoming values are grayscale therefore r component is sufficient

                 
                // Loop over square with size radius * radius (use symmetry so only 1/4 needs to be tested).
                // Discard all points that are not part of the circle
                // Collect data and save all intensities to filterValues
                int idx = 1;
                int total = 1;
                vec3 cur_normal;
                vec3 cur_position;
                float cur_curvature;
                float cur;
                for(int x = 0; x <= radius; x++){
                    for(int y = 0; y <= radius; y++){
                        if(x == 0 && y == 0)
                            continue;
                        else if(circularNeighborhood && x*x + y*y > radius * radius){
                            continue;
                        }
                        else{
                            ++total;
                            cur_normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy) + ivec2(x,y), 0).rgb;
                            cur_position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(x,y), 0).rgb;
                            cur_curvature = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(x,y), 0).z;
                            cur = dot(cur_normal, lightdir);
                            cur /= sqrt(cutOff * abs(cur_curvature) * (2 - cutOff * abs(cur_curvature)));
                            if(cur <= col)
                                ++darker;
                            if(cur > maxIntensity)
                                maxIntensity = cur;
                            filterValues[idx] = cur;
                            idx++;

                            if(x != 0){
                                ++total;
                                cur_normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy) + ivec2(-x,y), 0).rgb;
                                cur_position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(-x,y), 0).rgb;
                                cur_curvature = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(-x,y), 0).z;
                                cur = dot(cur_normal, lightdir);
                                cur /= sqrt(cutOff * abs(cur_curvature) * (2 - cutOff * abs(cur_curvature)));
                                if(cur <= col)
                                    ++darker;
                                if(cur > maxIntensity)
                                    maxIntensity = cur;
                                filterValues[idx] = cur;
                                idx++;
                                
                                if(y != 0){
                                    ++total;
                                    cur_normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy) + ivec2(-x,-y), 0).rgb;
                                    cur_position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(-x,-y), 0).rgb;
                                    cur_curvature = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(-x,-y), 0).z;
                                    cur = dot(cur_normal, lightdir);
                                    cur /= sqrt(cutOff * abs(cur_curvature) * (2 - cutOff * abs(cur_curvature)));
                                    if(cur <= col)
                                        ++darker;
                                    if(cur > maxIntensity)
                                        maxIntensity = cur;
                                    filterValues[idx] = cur;
                                    idx++;
                                }
                            }

                            if(y!= 0){
                                ++total;
                                cur_normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy) + ivec2(x,-y), 0).rgb;
                                cur_position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(x,-y), 0).rgb;
                                cur_curvature = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(x,-y), 0).z;
                                cur = dot(cur_normal, lightdir);
                                cur /= sqrt(cutOff * abs(cur_curvature) * (2 - cutOff * abs(cur_curvature)));
                                if(cur <= col)
                                    ++darker;
                                if(cur > maxIntensity)
                                    maxIntensity = cur;
                                filterValues[idx] = cur;
                                idx++;
                            }

                        }
                    }
                }
                if(darker > neighbourThreshold * total){
                    discard;
                }
                if(maxIntensity - col <= intensityDiffThreshold){
                    discard;
                }
                // //Median filtering
                if(medianFilter){
                    for(int n = total-1; n > 0; n = n - 1){
                        for(int i = 0; i < n; ++i){
                            float minimum = min(filterValues[i], filterValues[i+1]);
                            filterValues[i+1] = max(filterValues[i], filterValues[i+1]);
                            filterValues[i] = minimum;
                        }
                    }
                    // assign col to the median
                    col = filterValues[int(floor(total * 1.0 / 2.0))];
                }

                col = 1.0 - col; //invert color because background is dark

                FragColor = vec4(col, col, col, 1.0);
            }
          -->
        </snippet>
      </shader>
        <shader name="C">
          <snippet type="version">330</snippet>
          <snippet type="string">
            <!--
            out vec4 FragColor;
            in vec2 TexCoords;

            uniform sampler2D normalTexture;
            uniform sampler2D positionTexture;
            uniform sampler2D depthTexture;
            uniform float cutOff;
            uniform bool orthogonal_view;
            uniform int level_max;

            void main()
            {
                vec3 normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy), 0).rgb;  
                if(normal == vec3(0.0)){
                    discard;
                }
                vec3 lightdir;
                if(orthogonal_view)
                    lightdir = vec3(0.0,0.0,1.0);
                else{
                    vec3 position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy), 0).rgb;
                    lightdir = normalize(vec3(0.0, 0.0, 0.0) - position); 
                }
                // vec2 depth = texelFetch(depthTexture,ivec2(0,0), level_max - 1).xy;
                // float rel_depth = (position.z - depth.y) / (depth.x - depth.y);
                float dotp = dot(normal, lightdir);
                float col = dotp;
                
                if(col > cutOff)
                    discard;

                col = 1.0 - col; //invert color because background is dark

                FragColor = vec4(vec3(col), 1.0);
            }
          -->
        </snippet>
      </shader>
        <shader name="C_Curvature">
          <snippet type="version">330</snippet>
          <snippet type="string">
            <!--
            out vec4 FragColor;
            in vec2 TexCoords;

            uniform sampler2D normalTexture;
            uniform sampler2D positionTexture;
            uniform sampler2D curvatureTexture;
            uniform sampler2D depthTexture;
            uniform int level_max;
            uniform float cutOff;
            uniform bool orthogonal_view;
            uniform bool orthoproj;
            uniform float near_plane;

            void main()
            {
                vec3 position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy), 0).rgb;
                vec3 normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy), 0).rgb;  
                if(normal == vec3(0.0)){
                    discard;
                }
                vec3 lightdir;
                if(orthogonal_view)
                    lightdir = vec3(0.0,0.0,1.0);
                else{
                    lightdir = normalize(vec3(0.0, 0.0, 0.0) - position); 
                }
                float col = dot(normal, lightdir);
                
                vec2 depth = texelFetch(depthTexture,ivec2(0,0), level_max - 1).xy; // Maximum and minimum value of depths
                float rel_depth = (position.z - depth.y) / (depth.x - depth.y);
                float curvature = texelFetch(curvatureTexture, ivec2(gl_FragCoord.xy), 0).r;
                // If perspective projection was used to generate the textures, scale curvature for constant width in parts that are further away
                if(!orthoproj){
                    curvature *= position.z / near_plane;
                }

                if(col > sqrt(cutOff * abs(curvature) * (2 - cutOff * abs(curvature))))
                    discard;

                col = 1.0 - col; //invert color because background is dark

                FragColor = vec4(col, col, col, 1.0);
            }
          -->
        </snippet>
      </shader>
      </namespace>

        <namespace name="curvature">
        <shader name="evans">
          <snippet type="version">450</snippet>
          <snippet type="string">
            <!--


            out vec4 fragCurvature;

            uniform sampler2D tex_fragPosition;
            uniform sampler2D tex_fragNormal;


            void main() {
                vec4 passPosition_view = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy), 0);
                vec4 passNormal_view = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy), 0);
                if(passPosition_view == vec4(0.0))
                    discard;

                vec3 n = normalize(passNormal_view.xyz);

                vec3 pixelPositionLeft = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0).xyz;
                vec3 pixelPositionTop = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;
                vec3 pixelPositionRight = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;
                vec3 pixelPositionBottom = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,1)), 0).xyz;

                // Compute curvature
                vec3 dx = dFdx(n) / length(pixelPositionLeft - pixelPositionRight); // Das ist zur Normalisierung, da man nicht weiß wie weit die einzelnen Pixel im view space tatsächlich auseinander liegen und man schlussendlich in jedem fragemnt shader Lauf gleiche Abstände haben möchte
                vec3 dy = dFdy(n) / length(pixelPositionTop - pixelPositionBottom);
                vec3 xneg = n - dx;//Das hier sind dann quasi die neuen ein bisschen verschobenen Normalen aber äquivalente Abstände für alle fragment shader läufe
                vec3 xpos = n + dx;
                vec3 yneg = n - dy;
                vec3 ypos = n + dy;
                float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x);

                fragCurvature = vec4(vec3(curvature), 1.0);
            }
            -->
            </snippet>
        </shader>

        <shader name="mean">
          <snippet type="version">330</snippet>
          <snippet type="string">
            <!--


            out vec4 fragCurvature;

            uniform sampler2D tex_fragPosition;
            uniform sampler2D tex_fragNormal;


            void main() {
                vec4 passPosition_view = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy), 0);
                vec4 passNormal_view = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy), 0);
                if(passPosition_view == vec4(0.0))
                    discard;

                vec3 n = normalize(passNormal_view.xyz);

                vec3 pLeft = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0).xyz;
                vec3 pTop = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;
                vec3 pRight = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;
                vec3 pBottom = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,1)), 0).xyz;

                vec3 dx = dFdx(n) / length(pLeft - pRight); // Das ist zur Normalisierung, da man nicht weiß wie weit die einzelnen Pixel im view space tatsächlich auseinander liegen und man schlussendlich in jedem fragemnt shader Lauf gleiche Abstände haben möchte
                vec3 dy = dFdy(n) / length(pTop - pBottom);
                
                float curvature = (-(dx.x + dy.y)/n.z + (n.x * dx.z + n.y * dy.z) / (n.z * n.z)) / -2;

                fragCurvature = vec4(vec3(curvature), 1.0);
            }
            -->
            </snippet>
        </shader>

        <shader name="normal">
          <snippet type="version">330</snippet>
          <snippet type="string">
            <!--
            out vec4 fragCurvature;

            uniform sampler2D tex_fragPosition;
            uniform sampler2D tex_fragNormal;


            void main() {
                vec4 passPosition_view = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy), 0);
                vec4 passNormal_view = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy), 0);
                if(passPosition_view == vec4(0.0))
                    discard;

                vec3 p = passPosition_view.xyz;
                vec3 n = normalize(passNormal_view.xyz);

                //TODO: Bottom und Top vertauscht?

                vec3 pLeft = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0).xyz;
                vec3 pTop = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;
                vec3 pRight = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;
                vec3 pBottom = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,1)), 0).xyz;

                float curvatureLeft = dot(n, p - pLeft) / (length(p-pLeft) * length(p-pLeft));
                float curvatureTop = dot(n , p - pTop) / (length(pTop - p) * length(pTop - p));
                float curvatureRight = dot(n, p - pRight) / (length(pRight - p) * length(pRight - p));
                float curvatureBottom = dot(n, p - pBottom) / (length(pBottom - p) * length(pBottom - p));

                float curvature = (curvatureLeft + curvatureTop + curvatureRight + curvatureBottom) / 4;
                fragCurvature = vec4(vec3(curvature), 1.0);
            }


            // out vec4 fragCurvature;

            // uniform sampler2D tex_fragPosition;
            // uniform sampler2D tex_fragNormal;


            // void main() {
            //     vec4 passPosition_view = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy), 0);
            //     vec4 passNormal_view = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy), 0);
            //     if(passPosition_view == vec4(0.0))
            //         discard;

            //     vec3 p = passPosition_view.xyz;
            //     vec3 n = normalize(passNormal_view.xyz);

            //     vec3 pLeft = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0).xyz;
            //     vec3 pTop = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;
            //     vec3 pRight = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;
            //     vec3 pBottom = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,1)), 0).xyz;

            //     // Compute curvature for all "edges" in the 4-neighborhood
            //     float curvatureLeft = 2 * dot(n, p - pLeft) / (length(p-pLeft) * length(p-pLeft));
            //     float curvatureTop = 2 * dot(n, p - pTop) / (length(pTop - p) * length(pTop - p));
            //     float curvatureRight = 2 * dot(n, p - pRight) / (length(pRight - p) * length(pRight - p));
            //     float curvatureBottom = 2 * dot(n, p - pBottom) / (length(pBottom - p) * length(pBottom - p));

            //     float curvature = (curvatureLeft - curvatureRight) / 4;

            //     fragCurvature = vec4(vec3(curvature), 1.0);
            // }
            -->
            </snippet>
        </shader>
        <shader name="nathanReed">
          <snippet type="version">330</snippet>
          <snippet type="string">
            <!--


            out vec4 fragCurvature;

            uniform sampler2D tex_fragPosition;
            uniform sampler2D tex_fragNormal;


            void main() {
                vec4 passPosition_view = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy), 0);
                vec4 passNormal_view = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy), 0);
                if(passPosition_view == vec4(0.0))
                    discard;

                vec3 p = passPosition_view.xyz;
                vec3 n = normalize(passNormal_view.xyz);

                //TODO: Bottom und Top vertauscht?

                vec3 pLeft = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0).xyz;
                vec3 pTop = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;
                vec3 pRight = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;
                vec3 pBottom = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,1)), 0).xyz;

                vec3 nLeft = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0).xyz;
                vec3 nTop = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;
                vec3 nRight = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;
                vec3 nBottom = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(0,1)), 0).xyz;

                // Compute curvature for all "edges" in the 4-neighborhood
                float curvatureLeft = dot(n - nLeft, p - pLeft) / (length(p-pLeft) * length(p-pLeft));
                float curvatureTop = dot(n- nTop, p - pTop) / (length(pTop - p) * length(pTop - p));
                float curvatureRight = dot(n -nRight, p - pRight) / (length(pRight - p) * length(pRight - p));
                float curvatureBottom = dot(n -nBottom, p - pBottom) / (length(pBottom - p) * length(pBottom - p));

                float curvature = (curvatureLeft + curvatureTop + curvatureRight + curvatureBottom) / 4;

                fragCurvature = vec4(vec3(curvature), 1.0);
            }
            -->
            </snippet>
        </shader>
        <shader name="prantlmean">
          <snippet type="version">420</snippet>
          <snippet type="string">
            <!--
			#define TRIANGLE_VERTICES  3


            out vec4 fragCurvature;

            uniform sampler2D tex_fragPosition;
            uniform sampler2D tex_fragNormal;

//Begin

			vec2 CalcCurvature_ShapeOperator(vec3 a, vec3 b, vec3 c, vec3 an, vec3 bn, vec3 cn)
			{
	
				vec3 local_trianglePos[TRIANGLE_VERTICES];
				vec3 local_triangleNor[TRIANGLE_VERTICES];

	
				//=========================================================================================================

				vec3 _ba_ = (b - a);
				vec3 _ca_ = (c - a);

	
	
				vec3 axis[TRIANGLE_VERTICES];
				axis[0] = normalize(_ba_);
				axis[2] = normalize(cross(axis[0], _ca_));    
				axis[1] = normalize(cross(axis[0], axis[2]));
				
				// mat3 transformMatrix = mat3(axis[0], axis[1], axis[2]);  
                // transformMatrix = transpose(transformMatrix);
                mat3 transformMatrix = mat3(axis[0][0], axis[1][0], axis[2][0],
                                            axis[0][1], axis[1][1], axis[2][1],
                                            axis[0][2], axis[1][2], axis[2][2]);
				
				local_trianglePos[0] = vec3(0,0,0);
				local_triangleNor[0] = transformMatrix * an;
	
				local_trianglePos[1] = transformMatrix * _ba_;	
				local_triangleNor[1] = transformMatrix * bn;

				local_trianglePos[2] = transformMatrix * _ca_;	
				local_triangleNor[2] = transformMatrix * cn;
	
				vec3 u;
				vec3 v;

				vec3 du;
				vec3 dv;

				u.x = local_trianglePos[1].x - local_trianglePos[0].x;
				u.y = local_trianglePos[2].x - local_trianglePos[1].x;
				u.z = local_trianglePos[0].x - local_trianglePos[2].x;

				v.x = local_trianglePos[1].y - local_trianglePos[0].y;
				v.y = local_trianglePos[2].y - local_trianglePos[1].y;
				v.z = local_trianglePos[0].y - local_trianglePos[2].y;
	

				du.x = local_triangleNor[1].x - local_triangleNor[0].x;
				du.y = local_triangleNor[2].x - local_triangleNor[1].x;
				du.z = local_triangleNor[0].x - local_triangleNor[2].x;

				dv.x = local_triangleNor[1].y - local_triangleNor[0].y;
				dv.y = local_triangleNor[2].y - local_triangleNor[1].y;	
				dv.z = local_triangleNor[0].y - local_triangleNor[2].y;
	
				//===============================================================================


				
				//inverse of 3x3 matrix
				//invB = inverse of B

				float aa = dot(u, u);
				float bb = dot(u, v);
				float cc = dot(v, v);

				float invB_B = -(bb * cc);
				float invB_C =  (bb * bb);
				float invB_D =  (aa * cc);
				float invB_E = -(aa * bb);
				float invB_A = -invB_C + (cc * cc) + invB_D;
				float invB_F =  (aa * aa) + invB_D - invB_C;

				float determinantB = 1.0 / ((aa + cc) * (invB_D - invB_C));



				//=======================================================================================

				//col based matrices
				mat3 resLeft;
				mat3 resRight;
	
				resLeft[0][0] = v.x * invB_B + u.x * invB_A;
				resLeft[0][1] = v.x * invB_C + u.x * invB_B;
				resLeft[0][2] = v.y * invB_B + u.y * invB_A;
				resRight[0][0] = v.y * invB_C + u.y * invB_B;
				resRight[0][1] = v.z * invB_B + u.z * invB_A;
				resRight[0][2] = v.z * invB_C + u.z * invB_B;

				resLeft[1][0] = v.x * invB_D + u.x * invB_B;
				resLeft[1][1] = v.x * invB_E + u.x * invB_D;
				resLeft[1][2] = v.y * invB_D + u.y * invB_B;
				resRight[1][0] = v.y * invB_E + u.y * invB_D;
				resRight[1][1] = v.z * invB_D + u.z * invB_B;
				resRight[1][2] = v.z * invB_E + u.z * invB_D;

				resLeft[2][0] = v.x * invB_E + u.x * invB_C;
				resLeft[2][1] = v.x * invB_F + u.x * invB_E;
				resLeft[2][2] = v.y * invB_E + u.y * invB_C;
				resRight[2][0] = v.y * invB_F + u.y * invB_E;
				resRight[2][1] = v.z * invB_E + u.z * invB_C;
				resRight[2][2] = v.z * invB_F + u.z * invB_E;

				//================================================================================
				
				vec3 finalM_gpu_a = vec3(du.x, dv.x, du.y) * resLeft;
				vec3 finalM_gpu_b = vec3(dv.y, du.z, dv.z) * resRight;

				vec3 tmp_gpu = determinantB * (finalM_gpu_a + finalM_gpu_b);

				//================================================================================


				float D = dot(tmp_gpu, tmp_gpu) + (3.0 * tmp_gpu.y * tmp_gpu.y - 2.0 * tmp_gpu.x * tmp_gpu.z);
	
				if (D < 0) D = 0;
				float sqrtD = sqrt(D);

				float L1 = ((tmp_gpu.x + tmp_gpu.z) + sqrtD) * 0.5;
				float L2 = ((tmp_gpu.x + tmp_gpu.z) - sqrtD) * 0.5;


				// float gauss = L1 * L2;
	
				// float mean = 0.5 * (L1 + L2);

				return vec2(L1, L2);
			}


            void main() {
                vec4 passPosition_view = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy), 0);
                vec4 passNormal_view = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy), 0);
                if(passPosition_view == vec4(0.0))
                    discard;

                vec3 p = passPosition_view.xyz;
                vec3 n = normalize(passNormal_view.xyz);

                //TODO: Bottom und Top vertauscht?

                vec3 pTop = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;
                vec3 pRight = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;

                vec3 nTop = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;
                vec3 nRight = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;

                // Compute curvature for all "edges" in the 4-neighborhood
                vec2 eigenvalues = CalcCurvature_ShapeOperator(p, pRight, pTop, n, nRight, nTop);
                float mean_curv = 0.5 * (eigenvalues.x + eigenvalues.y);

                fragCurvature = vec4(vec3(mean_curv),1.0);
            }
                
            -->
            </snippet>
        </shader>

        <shader name="prantl2mean">
          <snippet type="version">420</snippet>
          <snippet type="string">
            <!--
			#define TRIANGLE_VERTICES  3


            out vec4 fragCurvature;

            uniform sampler2D tex_fragPosition;
            uniform sampler2D tex_fragNormal;

//Begin
			vec2 CalcCurvature_ShapeOperator_2edge(vec3 a, vec3 b, vec3 c, vec3 an, vec3 bn, vec3 cn)
			{
	
				vec3 local_trianglePos[TRIANGLE_VERTICES];
				vec3 local_triangleNor[TRIANGLE_VERTICES];

	
				//=========================================================================================================

				vec3 _ba_ = (b - a);
				vec3 _ca_ = (c - a);

	
	
				vec3 axis[TRIANGLE_VERTICES];
				axis[0] = normalize(_ba_);
				axis[2] = normalize(cross(axis[0], _ca_));    
				axis[1] = normalize(cross(axis[0], axis[2]));




                mat3 transformMatrix = mat3(axis[0][0], axis[1][0], axis[2][0],
                                            axis[0][1], axis[1][1], axis[2][1],
                                            axis[0][2], axis[1][2], axis[2][2]);
				

				local_trianglePos[0] = vec3(0, 0, 0);
				local_triangleNor[0] = transformMatrix* an;
	
				local_trianglePos[1] = transformMatrix* _ba_;	
				local_triangleNor[1] = transformMatrix* bn;

				local_trianglePos[2] = transformMatrix* _ca_;	
				local_triangleNor[2] = transformMatrix* cn;
	
				vec2 u;
				vec2 v;

				vec2 du;
				vec2 dv;

				u.x = local_trianglePos[1].x - local_trianglePos[0].x;
				u.y = local_trianglePos[2].x - local_trianglePos[1].x;
	
				v.x = local_trianglePos[1].y - local_trianglePos[0].y;
				v.y = local_trianglePos[2].y - local_trianglePos[1].y;
		
				du.x = local_triangleNor[1].x - local_triangleNor[0].x;
				du.y = local_triangleNor[2].x - local_triangleNor[1].x;
	
				dv.x = local_triangleNor[1].y - local_triangleNor[0].y;
				dv.y = local_triangleNor[2].y - local_triangleNor[1].y;	
		
				//===============================================================================
				

				//inverse of 3x3 matrix
				//invB = inverse of B

				float aa = dot(u, u);
				float bb = dot(u, v);
				float cc = dot(v, v);

				float invB_B = -(bb * cc);
				float invB_C =  (bb * bb);
				float invB_D =  (aa * cc);
				float invB_E = -(aa * bb);
				float invB_A = -invB_C + (cc * cc) + invB_D;
				float invB_F =  (aa * aa) + invB_D - invB_C;

				float determinantB = 1.0 / ((aa + cc) * (invB_D - invB_C));



				//=======================================================================================

				mat4 tmp;
	
	
				tmp[0][0] = v.x * invB_B + u.x * invB_A;
				tmp[0][1] = v.x * invB_C + u.x * invB_B;
				tmp[0][2] = v.y * invB_B + u.y * invB_A;
				tmp[0][3] = v.y * invB_C + u.y * invB_B;


				tmp[1][0] = v.x * invB_D + u.x * invB_B;
				tmp[1][1] = v.x * invB_E + u.x * invB_D;
				tmp[1][2] = v.y * invB_D + u.y * invB_B;
				tmp[1][3] = v.y * invB_E + u.y * invB_D;


				tmp[2][0] = v.x * invB_E + u.x * invB_C;
				tmp[2][1] = v.x * invB_F + u.x * invB_E;
				tmp[2][2] = v.y * invB_E + u.y * invB_C;
				tmp[2][3] = v.y * invB_F + u.y * invB_E;


				tmp[3][0] = 0;
				tmp[3][1] = 0;
				tmp[3][2] = 0;
				tmp[3][3] = 0;

				//================================================================================

				vec4 tmp_gpu = determinantB * vec4(du.x, dv.x, du.y, dv.y) * tmp;
				
				//================================================================================


				float D = dot(tmp_gpu, tmp_gpu) + (3.0 * tmp_gpu.y * tmp_gpu.y - 2.0 * tmp_gpu.x * tmp_gpu.z);
	
				if (D < 0) D = 0;
				float sqrtD = sqrt(D);

				float L1 = ((tmp_gpu.x + tmp_gpu.z) + sqrtD) * 0.5;
				float L2 = ((tmp_gpu.x + tmp_gpu.z) - sqrtD) * 0.5;


				// float gauss = L1 * L2;
	
				// float mean = 0.5 * (L1 + L2);

				return vec2(L1, L2);
			}

            void main() {
                vec4 passPosition_view = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy), 0);
                vec4 passNormal_view = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy), 0);
                if(passPosition_view == vec4(0.0))
                    discard;

                vec3 p = passPosition_view.xyz;
                vec3 n = normalize(passNormal_view.xyz);

                //TODO: Bottom und Top vertauscht?

                vec3 pTop = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;
                vec3 pRight = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;

                vec3 nTop = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;
                vec3 nRight = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;

                // Compute curvature for all "edges" in the 4-neighborhood
                vec2 eigenvalues = CalcCurvature_ShapeOperator_2edge(p, pRight, pTop, n, nRight, nTop);
                float mean_curv = 0.5 * (eigenvalues.x + eigenvalues.y);

                fragCurvature = vec4(vec3(mean_curv),1.0);
            }
                
            -->
            </snippet>
        </shader>
        <shader name="prantlradial">
          <snippet type="version">420</snippet>
          <snippet type="string">
            <!--
			#define TRIANGLE_VERTICES  3


            out vec4 fragCurvature;

            uniform sampler2D tex_fragPosition;
            uniform sampler2D tex_fragNormal;

//Begin

			float CalcCurvature_ShapeOperator(vec3 a, vec3 b, vec3 c, vec3 an, vec3 bn, vec3 cn, vec3 p)
			{
	
				vec3 local_trianglePos[TRIANGLE_VERTICES];
				vec3 local_triangleNor[TRIANGLE_VERTICES];

	
				//=========================================================================================================

				vec3 _ba_ = (b - a);
				vec3 _ca_ = (c - a);

	
	
				vec3 axis[TRIANGLE_VERTICES];
				axis[0] = normalize(_ba_);
				axis[2] = normalize(cross(axis[0], _ca_));    
				axis[1] = normalize(cross(axis[0], axis[2]));
				
				// mat3 transformMatrix = mat3(axis[0], axis[1], axis[2]);  
                // transformMatrix = transpose(transformMatrix);
                mat3 transformMatrix = mat3(axis[0][0], axis[1][0], axis[2][0],
                                            axis[0][1], axis[1][1], axis[2][1],
                                            axis[0][2], axis[1][2], axis[2][2]);
				
				local_trianglePos[0] = vec3(0,0,0);
				local_triangleNor[0] = transformMatrix * an;
	
				local_trianglePos[1] = transformMatrix * _ba_;	
				local_triangleNor[1] = transformMatrix * bn;

				local_trianglePos[2] = transformMatrix * _ca_;	
				local_triangleNor[2] = transformMatrix * cn;
	
				vec3 u;
				vec3 v;

				vec3 du;
				vec3 dv;

				u.x = local_trianglePos[1].x - local_trianglePos[0].x;
				u.y = local_trianglePos[2].x - local_trianglePos[1].x;
				u.z = local_trianglePos[0].x - local_trianglePos[2].x;

				v.x = local_trianglePos[1].y - local_trianglePos[0].y;
				v.y = local_trianglePos[2].y - local_trianglePos[1].y;
				v.z = local_trianglePos[0].y - local_trianglePos[2].y;
	

				du.x = local_triangleNor[1].x - local_triangleNor[0].x;
				du.y = local_triangleNor[2].x - local_triangleNor[1].x;
				du.z = local_triangleNor[0].x - local_triangleNor[2].x;

				dv.x = local_triangleNor[1].y - local_triangleNor[0].y;
				dv.y = local_triangleNor[2].y - local_triangleNor[1].y;	
				dv.z = local_triangleNor[0].y - local_triangleNor[2].y;
	
				//===============================================================================


				
				//inverse of 3x3 matrix
				//invB = inverse of B

				float aa = dot(u, u);
				float bb = dot(u, v);
				float cc = dot(v, v);

				float invB_B = -(bb * cc);
				float invB_C =  (bb * bb);
				float invB_D =  (aa * cc);
				float invB_E = -(aa * bb);
				float invB_A = -invB_C + (cc * cc) + invB_D;
				float invB_F =  (aa * aa) + invB_D - invB_C;

				float determinantB = 1.0 / ((aa + cc) * (invB_D - invB_C));



				//=======================================================================================

				//col based matrices
				mat3 resLeft;
				mat3 resRight;
	
				resLeft[0][0] = v.x * invB_B + u.x * invB_A;
				resLeft[0][1] = v.x * invB_C + u.x * invB_B;
				resLeft[0][2] = v.y * invB_B + u.y * invB_A;
				resRight[0][0] = v.y * invB_C + u.y * invB_B;
				resRight[0][1] = v.z * invB_B + u.z * invB_A;
				resRight[0][2] = v.z * invB_C + u.z * invB_B;

				resLeft[1][0] = v.x * invB_D + u.x * invB_B;
				resLeft[1][1] = v.x * invB_E + u.x * invB_D;
				resLeft[1][2] = v.y * invB_D + u.y * invB_B;
				resRight[1][0] = v.y * invB_E + u.y * invB_D;
				resRight[1][1] = v.z * invB_D + u.z * invB_B;
				resRight[1][2] = v.z * invB_E + u.z * invB_D;

				resLeft[2][0] = v.x * invB_E + u.x * invB_C;
				resLeft[2][1] = v.x * invB_F + u.x * invB_E;
				resLeft[2][2] = v.y * invB_E + u.y * invB_C;
				resRight[2][0] = v.y * invB_F + u.y * invB_E;
				resRight[2][1] = v.z * invB_E + u.z * invB_C;
				resRight[2][2] = v.z * invB_F + u.z * invB_E;

				//================================================================================
				
				vec3 finalM_gpu_a = vec3(du.x, dv.x, du.y) * resLeft;
				vec3 finalM_gpu_b = vec3(dv.y, du.z, dv.z) * resRight;

				vec3 tmp_gpu = determinantB * (finalM_gpu_a + finalM_gpu_b);

				//================================================================================


				float D = dot(tmp_gpu, tmp_gpu) + (3.0 * tmp_gpu.y * tmp_gpu.y - 2.0 * tmp_gpu.x * tmp_gpu.z);
	
				if (D < 0) D = 0;
				float sqrtD = sqrt(D);

				float L1 = ((tmp_gpu.x + tmp_gpu.z) + sqrtD) * 0.5;
				float L2 = ((tmp_gpu.x + tmp_gpu.z) - sqrtD) * 0.5;

                //https://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html
                vec2 eigenvec1;

                if(tmp_gpu.y ==0 ){
                    eigenvec1.x = L1 - tmp_gpu.z;
                    eigenvec1.y = tmp_gpu.y;
                }
                else
                {
                    eigenvec1 = vec2(1.0, 0.0);
                }

                vec3 viewdir = normalize(vec3(0.0, 0.0, 0.0) - p); 
                viewdir = transformMatrix * viewdir; //transform viewdir into local coordinates
                vec3 mean_normal = local_triangleNor[0] + local_triangleNor[1] + local_triangleNor[2];
                mean_normal /= 3;
                //TODO: get more accurate plane normal
                vec2 proj_viewdir = (viewdir * (1.0 - dot(viewdir,mean_normal))).xy; //project onto tangent plane
                float cos2 = dot(proj_viewdir, eigenvec1);
                float radial_curv = L1 * cos2 + L2 * (1- cos2);

				return radial_curv;
			}


            void main() {
                vec4 passPosition_view = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy), 0);
                vec4 passNormal_view = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy), 0);
                if(passPosition_view == vec4(0.0))
                    discard;

                vec3 p = passPosition_view.xyz;
                vec3 n = normalize(passNormal_view.xyz);

                //TODO: Bottom und Top vertauscht?

                vec3 pTop = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;
                vec3 pRight = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;

                vec3 nTop = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;
                vec3 nRight = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;

                // Compute curvature for all "edges" in the 4-neighborhood
                float curv = CalcCurvature_ShapeOperator(p, pRight, pTop, n, nRight, nTop, p);

                fragCurvature = vec4(vec3(curv),1.0);
            }
                
            -->
            </snippet>
        </shader>

        <shader name="prantl2radial">
          <snippet type="version">420</snippet>
          <snippet type="string">
            <!--
			#define TRIANGLE_VERTICES  3


            out vec4 fragCurvature;

            uniform sampler2D tex_fragPosition;
            uniform sampler2D tex_fragNormal;

//Begin
			float CalcCurvature_ShapeOperator_2edge(vec3 a, vec3 b, vec3 c, vec3 an, vec3 bn, vec3 cn, vec3 p)
			{
	
				vec3 local_trianglePos[TRIANGLE_VERTICES];
				vec3 local_triangleNor[TRIANGLE_VERTICES];

	
				//=========================================================================================================

				vec3 _ba_ = (b - a);
				vec3 _ca_ = (c - a);

	
	
				vec3 axis[TRIANGLE_VERTICES];
				axis[0] = normalize(_ba_);
				axis[2] = normalize(cross(axis[0], _ca_));    
				axis[1] = normalize(cross(axis[0], axis[2]));




                mat3 transformMatrix = mat3(axis[0][0], axis[1][0], axis[2][0],
                                            axis[0][1], axis[1][1], axis[2][1],
                                            axis[0][2], axis[1][2], axis[2][2]);
				

				local_trianglePos[0] = vec3(0, 0, 0);
				local_triangleNor[0] = transformMatrix* an;
	
				local_trianglePos[1] = transformMatrix* _ba_;	
				local_triangleNor[1] = transformMatrix* bn;

				local_trianglePos[2] = transformMatrix* _ca_;	
				local_triangleNor[2] = transformMatrix* cn;
	
				vec2 u;
				vec2 v;

				vec2 du;
				vec2 dv;

				u.x = local_trianglePos[1].x - local_trianglePos[0].x;
				u.y = local_trianglePos[2].x - local_trianglePos[1].x;
	
				v.x = local_trianglePos[1].y - local_trianglePos[0].y;
				v.y = local_trianglePos[2].y - local_trianglePos[1].y;
		
				du.x = local_triangleNor[1].x - local_triangleNor[0].x;
				du.y = local_triangleNor[2].x - local_triangleNor[1].x;
	
				dv.x = local_triangleNor[1].y - local_triangleNor[0].y;
				dv.y = local_triangleNor[2].y - local_triangleNor[1].y;	
		
				//===============================================================================
				

				//inverse of 3x3 matrix
				//invB = inverse of B

				float aa = dot(u, u);
				float bb = dot(u, v);
				float cc = dot(v, v);

				float invB_B = -(bb * cc);
				float invB_C =  (bb * bb);
				float invB_D =  (aa * cc);
				float invB_E = -(aa * bb);
				float invB_A = -invB_C + (cc * cc) + invB_D;
				float invB_F =  (aa * aa) + invB_D - invB_C;

				float determinantB = 1.0 / ((aa + cc) * (invB_D - invB_C));



				//=======================================================================================

				mat4 tmp;
	
	
				tmp[0][0] = v.x * invB_B + u.x * invB_A;
				tmp[0][1] = v.x * invB_C + u.x * invB_B;
				tmp[0][2] = v.y * invB_B + u.y * invB_A;
				tmp[0][3] = v.y * invB_C + u.y * invB_B;


				tmp[1][0] = v.x * invB_D + u.x * invB_B;
				tmp[1][1] = v.x * invB_E + u.x * invB_D;
				tmp[1][2] = v.y * invB_D + u.y * invB_B;
				tmp[1][3] = v.y * invB_E + u.y * invB_D;


				tmp[2][0] = v.x * invB_E + u.x * invB_C;
				tmp[2][1] = v.x * invB_F + u.x * invB_E;
				tmp[2][2] = v.y * invB_E + u.y * invB_C;
				tmp[2][3] = v.y * invB_F + u.y * invB_E;


				tmp[3][0] = 0;
				tmp[3][1] = 0;
				tmp[3][2] = 0;
				tmp[3][3] = 0;

				//================================================================================

				vec4 tmp_gpu = determinantB * vec4(du.x, dv.x, du.y, dv.y) * tmp;
				
				//================================================================================


				float D = dot(tmp_gpu, tmp_gpu) + (3.0 * tmp_gpu.y * tmp_gpu.y - 2.0 * tmp_gpu.x * tmp_gpu.z);
	
				if (D < 0) D = 0;
				float sqrtD = sqrt(D);

				float L1 = ((tmp_gpu.x + tmp_gpu.z) + sqrtD) * 0.5;
				float L2 = ((tmp_gpu.x + tmp_gpu.z) - sqrtD) * 0.5;
                //https://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html
                //https://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html
                vec2 eigenvec1;

                if(tmp_gpu.y ==0 ){
                    eigenvec1.x = L1 - tmp_gpu.z;
                    eigenvec1.y = tmp_gpu.y;
                }
                else
                {
                    eigenvec1 = vec2(1.0, 0.0);
                }

                vec3 viewdir = normalize(vec3(0.0, 0.0, 0.0) - p); 
                viewdir = transformMatrix * viewdir; //transform viewdir into local coordinates
                vec3 mean_normal = local_triangleNor[0] + local_triangleNor[1] + local_triangleNor[2];
                mean_normal /= 3;
                //TODO: get more accurate plane normal
                vec2 proj_viewdir = (viewdir * (1.0 - dot(viewdir,mean_normal))).xy; //project onto tangent plane
                float cos2 = dot(proj_viewdir, eigenvec1);
                float radial_curv = L1 * cos2 + L2 * (1- cos2);

				return radial_curv;
			}

            void main() {
                vec4 passPosition_view = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy), 0);
                vec4 passNormal_view = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy), 0);
                if(passPosition_view == vec4(0.0))
                    discard;

                vec3 p = passPosition_view.xyz;
                vec3 n = normalize(passNormal_view.xyz);

                //TODO: Bottom und Top vertauscht?

                vec3 pTop = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;
                vec3 pRight = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;

                vec3 nTop = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;
                vec3 nRight = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;

                // Compute curvature for all "edges" in the 4-neighborhood
                float radial_curv = CalcCurvature_ShapeOperator_2edge(p, pRight, pTop, n, nRight, nTop, p);

                fragCurvature = vec4(vec3(radial_curv),1.0);
            }
                
            -->
            </snippet>
        </shader>
        
        <shader name="prantlgaussian">
          <snippet type="version">420</snippet>
          <snippet type="string">
            <!--
			#define TRIANGLE_VERTICES  3


            out vec4 fragCurvature;

            uniform sampler2D tex_fragPosition;
            uniform sampler2D tex_fragNormal;

//Begin

			vec2 CalcCurvature_ShapeOperator(vec3 a, vec3 b, vec3 c, vec3 an, vec3 bn, vec3 cn)
			{
	
				vec3 local_trianglePos[TRIANGLE_VERTICES];
				vec3 local_triangleNor[TRIANGLE_VERTICES];

	
				//=========================================================================================================

				vec3 _ba_ = (b - a);
				vec3 _ca_ = (c - a);

	
	
				vec3 axis[TRIANGLE_VERTICES];
				axis[0] = normalize(_ba_);
				axis[2] = normalize(cross(axis[0], _ca_));    
				axis[1] = normalize(cross(axis[0], axis[2]));
				
				// mat3 transformMatrix = mat3(axis[0], axis[1], axis[2]);  
                // transformMatrix = transpose(transformMatrix);
                mat3 transformMatrix = mat3(axis[0][0], axis[1][0], axis[2][0],
                                            axis[0][1], axis[1][1], axis[2][1],
                                            axis[0][2], axis[1][2], axis[2][2]);
				
				local_trianglePos[0] = vec3(0,0,0);
				local_triangleNor[0] = transformMatrix * an;
	
				local_trianglePos[1] = transformMatrix * _ba_;	
				local_triangleNor[1] = transformMatrix * bn;

				local_trianglePos[2] = transformMatrix * _ca_;	
				local_triangleNor[2] = transformMatrix * cn;
	
				vec3 u;
				vec3 v;

				vec3 du;
				vec3 dv;

				u.x = local_trianglePos[1].x - local_trianglePos[0].x;
				u.y = local_trianglePos[2].x - local_trianglePos[1].x;
				u.z = local_trianglePos[0].x - local_trianglePos[2].x;

				v.x = local_trianglePos[1].y - local_trianglePos[0].y;
				v.y = local_trianglePos[2].y - local_trianglePos[1].y;
				v.z = local_trianglePos[0].y - local_trianglePos[2].y;
	

				du.x = local_triangleNor[1].x - local_triangleNor[0].x;
				du.y = local_triangleNor[2].x - local_triangleNor[1].x;
				du.z = local_triangleNor[0].x - local_triangleNor[2].x;

				dv.x = local_triangleNor[1].y - local_triangleNor[0].y;
				dv.y = local_triangleNor[2].y - local_triangleNor[1].y;	
				dv.z = local_triangleNor[0].y - local_triangleNor[2].y;
	
				//===============================================================================


				
				//inverse of 3x3 matrix
				//invB = inverse of B

				float aa = dot(u, u);
				float bb = dot(u, v);
				float cc = dot(v, v);

				float invB_B = -(bb * cc);
				float invB_C =  (bb * bb);
				float invB_D =  (aa * cc);
				float invB_E = -(aa * bb);
				float invB_A = -invB_C + (cc * cc) + invB_D;
				float invB_F =  (aa * aa) + invB_D - invB_C;

				float determinantB = 1.0 / ((aa + cc) * (invB_D - invB_C));



				//=======================================================================================

				//col based matrices
				mat3 resLeft;
				mat3 resRight;
	
				resLeft[0][0] = v.x * invB_B + u.x * invB_A;
				resLeft[0][1] = v.x * invB_C + u.x * invB_B;
				resLeft[0][2] = v.y * invB_B + u.y * invB_A;
				resRight[0][0] = v.y * invB_C + u.y * invB_B;
				resRight[0][1] = v.z * invB_B + u.z * invB_A;
				resRight[0][2] = v.z * invB_C + u.z * invB_B;

				resLeft[1][0] = v.x * invB_D + u.x * invB_B;
				resLeft[1][1] = v.x * invB_E + u.x * invB_D;
				resLeft[1][2] = v.y * invB_D + u.y * invB_B;
				resRight[1][0] = v.y * invB_E + u.y * invB_D;
				resRight[1][1] = v.z * invB_D + u.z * invB_B;
				resRight[1][2] = v.z * invB_E + u.z * invB_D;

				resLeft[2][0] = v.x * invB_E + u.x * invB_C;
				resLeft[2][1] = v.x * invB_F + u.x * invB_E;
				resLeft[2][2] = v.y * invB_E + u.y * invB_C;
				resRight[2][0] = v.y * invB_F + u.y * invB_E;
				resRight[2][1] = v.z * invB_E + u.z * invB_C;
				resRight[2][2] = v.z * invB_F + u.z * invB_E;

				//================================================================================
				
				vec3 finalM_gpu_a = vec3(du.x, dv.x, du.y) * resLeft;
				vec3 finalM_gpu_b = vec3(dv.y, du.z, dv.z) * resRight;

				vec3 tmp_gpu = determinantB * (finalM_gpu_a + finalM_gpu_b);

				//================================================================================


				float D = dot(tmp_gpu, tmp_gpu) + (3.0 * tmp_gpu.y * tmp_gpu.y - 2.0 * tmp_gpu.x * tmp_gpu.z);
	
				if (D < 0) D = 0;
				float sqrtD = sqrt(D);

				float L1 = ((tmp_gpu.x + tmp_gpu.z) + sqrtD) * 0.5;
				float L2 = ((tmp_gpu.x + tmp_gpu.z) - sqrtD) * 0.5;


				// float gauss = L1 * L2;
	
				// float mean = 0.5 * (L1 + L2);

				return vec2(L1, L2);
			}


            void main() {
                vec4 passPosition_view = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy), 0);
                vec4 passNormal_view = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy), 0);
                if(passPosition_view == vec4(0.0))
                    discard;

                vec3 p = passPosition_view.xyz;
                vec3 n = normalize(passNormal_view.xyz);

                //TODO: Bottom und Top vertauscht?

                vec3 pTop = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;
                vec3 pRight = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;

                vec3 nTop = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;
                vec3 nRight = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;

                // Compute curvature for all "edges" in the 4-neighborhood
                vec2 eigenvalues = CalcCurvature_ShapeOperator(p, pRight, pTop, n, nRight, nTop);
                float gauss_curv = (eigenvalues.x * eigenvalues.y);

                fragCurvature = vec4(vec3(gauss_curv),1.0);
            }
                
            -->
            </snippet>
        </shader>

        <shader name="prantl2gaussian">
          <snippet type="version">420</snippet>
          <snippet type="string">
            <!--
			#define TRIANGLE_VERTICES  3


            out vec4 fragCurvature;

            uniform sampler2D tex_fragPosition;
            uniform sampler2D tex_fragNormal;

//Begin
			vec2 CalcCurvature_ShapeOperator_2edge(vec3 a, vec3 b, vec3 c, vec3 an, vec3 bn, vec3 cn)
			{
	
				vec3 local_trianglePos[TRIANGLE_VERTICES];
				vec3 local_triangleNor[TRIANGLE_VERTICES];

	
				//=========================================================================================================

				vec3 _ba_ = (b - a);
				vec3 _ca_ = (c - a);

	
	
				vec3 axis[TRIANGLE_VERTICES];
				axis[0] = normalize(_ba_);
				axis[2] = normalize(cross(axis[0], _ca_));    
				axis[1] = normalize(cross(axis[0], axis[2]));




                mat3 transformMatrix = mat3(axis[0][0], axis[1][0], axis[2][0],
                                            axis[0][1], axis[1][1], axis[2][1],
                                            axis[0][2], axis[1][2], axis[2][2]);
				

				local_trianglePos[0] = vec3(0, 0, 0);
				local_triangleNor[0] = transformMatrix* an;
	
				local_trianglePos[1] = transformMatrix* _ba_;	
				local_triangleNor[1] = transformMatrix* bn;

				local_trianglePos[2] = transformMatrix* _ca_;	
				local_triangleNor[2] = transformMatrix* cn;
	
				vec2 u;
				vec2 v;

				vec2 du;
				vec2 dv;

				u.x = local_trianglePos[1].x - local_trianglePos[0].x;
				u.y = local_trianglePos[2].x - local_trianglePos[1].x;
	
				v.x = local_trianglePos[1].y - local_trianglePos[0].y;
				v.y = local_trianglePos[2].y - local_trianglePos[1].y;
		
				du.x = local_triangleNor[1].x - local_triangleNor[0].x;
				du.y = local_triangleNor[2].x - local_triangleNor[1].x;
	
				dv.x = local_triangleNor[1].y - local_triangleNor[0].y;
				dv.y = local_triangleNor[2].y - local_triangleNor[1].y;	
		
				//===============================================================================
				

				//inverse of 3x3 matrix
				//invB = inverse of B

				float aa = dot(u, u);
				float bb = dot(u, v);
				float cc = dot(v, v);

				float invB_B = -(bb * cc);
				float invB_C =  (bb * bb);
				float invB_D =  (aa * cc);
				float invB_E = -(aa * bb);
				float invB_A = -invB_C + (cc * cc) + invB_D;
				float invB_F =  (aa * aa) + invB_D - invB_C;

				float determinantB = 1.0 / ((aa + cc) * (invB_D - invB_C));



				//=======================================================================================

				mat4 tmp;
	
	
				tmp[0][0] = v.x * invB_B + u.x * invB_A;
				tmp[0][1] = v.x * invB_C + u.x * invB_B;
				tmp[0][2] = v.y * invB_B + u.y * invB_A;
				tmp[0][3] = v.y * invB_C + u.y * invB_B;


				tmp[1][0] = v.x * invB_D + u.x * invB_B;
				tmp[1][1] = v.x * invB_E + u.x * invB_D;
				tmp[1][2] = v.y * invB_D + u.y * invB_B;
				tmp[1][3] = v.y * invB_E + u.y * invB_D;


				tmp[2][0] = v.x * invB_E + u.x * invB_C;
				tmp[2][1] = v.x * invB_F + u.x * invB_E;
				tmp[2][2] = v.y * invB_E + u.y * invB_C;
				tmp[2][3] = v.y * invB_F + u.y * invB_E;


				tmp[3][0] = 0;
				tmp[3][1] = 0;
				tmp[3][2] = 0;
				tmp[3][3] = 0;

				//================================================================================

				vec4 tmp_gpu = determinantB * vec4(du.x, dv.x, du.y, dv.y) * tmp;
				
				//================================================================================


				float D = dot(tmp_gpu, tmp_gpu) + (3.0 * tmp_gpu.y * tmp_gpu.y - 2.0 * tmp_gpu.x * tmp_gpu.z);
	
				if (D < 0) D = 0;
				float sqrtD = sqrt(D);

				float L1 = ((tmp_gpu.x + tmp_gpu.z) + sqrtD) * 0.5;
				float L2 = ((tmp_gpu.x + tmp_gpu.z) - sqrtD) * 0.5;


				// float gauss = L1 * L2;
	
				// float mean = 0.5 * (L1 + L2);

				return vec2(L1, L2);
			}

            void main() {
                vec4 passPosition_view = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy), 0);
                vec4 passNormal_view = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy), 0);
                if(passPosition_view == vec4(0.0))
                    discard;

                vec3 p = passPosition_view.xyz;
                vec3 n = normalize(passNormal_view.xyz);

                //TODO: Bottom und Top vertauscht?

                vec3 pTop = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;
                vec3 pRight = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;

                vec3 nTop = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;
                vec3 nRight = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;

                // Compute curvature for all "edges" in the 4-neighborhood
                vec2 eigenvalues = CalcCurvature_ShapeOperator_2edge(p, pRight, pTop, n, nRight, nTop);
                float gauss_curv = eigenvalues.x *  eigenvalues.y;

                fragCurvature = vec4(vec3(gauss_curv),1.0);
            }
                
            -->
            </snippet>
        </shader>
        
        <shader name="fragment">
          <snippet type="version">330</snippet>
          <snippet type="string">
            <!--
            out vec4 fragCurvature;

            uniform sampler2D tex_fragPosition;
            uniform sampler2D tex_fragCurvature;
            uniform sampler2D tex_fragNormal;

            vec4 showZerocrossing(float curvature, float curvatureDxy) {
                if(abs(curvature) <= 0.01 * curvatureDxy) {
                    return vec4(0);
                }
                return vec4(1);
            }

            void main() {
                vec3 pixelPosition = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy), 0).xyz;
                vec3 pixelNormal = normalize(texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy), 0).xyz);
                vec4 curvature = texelFetch(tex_fragCurvature, ivec2(gl_FragCoord.xy), 0);

                // if (curvature.xyz == vec3(1, 0, 0)) { // "Maske"
                //     fragCurvature=vec4(1);
                // }

                float f = 1.0;//0.01;
                float scaledCurvature = curvature.x * f;

                // TODO: use pixel 3D locations to calculate the derivative. Also smooth the result -> pull-push
                vec3 pixelPositionLeft = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0).xyz;
                vec3 pixelPositionTop = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;
                vec3 pixelPositionRight = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;
                vec3 pixelPositionBottom = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,1)), 0).xyz;

                float curvatureDx = dFdx(scaledCurvature); // / length(pixelPositionLeft - pixelPositionRight);
                float curvatureDy = dFdy(scaledCurvature); // / length(pixelPositionTop - pixelPositionBottom);
                vec2 curvatureDirection = (vec2(curvatureDx, curvatureDy));

                // create local coordinate system at the pixel position
                vec3 h = normalize(vec3(-1));
                vec3 U = cross(pixelNormal, h);
                vec3 V = cross(h, U);

                // project the view vector into the local system
                vec3 v = normalize(-pixelPosition);
                vec2 vProjected = vec2(dot(U,v), dot (V,v));

                float isSuggestiveContour = sign(dot(vProjected, curvatureDirection));

                if (scaledCurvature >= 0) {
                    fragCurvature = vec4(1) - vec4(scaledCurvature, 0, 0, 0);
                } else {
                    fragCurvature = vec4(1) - vec4(0, -scaledCurvature, 0, 0);
                }

                if(isSuggestiveContour > 0) {
                    fragCurvature *= showZerocrossing(scaledCurvature, length(curvatureDirection));
                }

            }
          -->
        </snippet>
      </shader>
        
      </namespace>
        <namespace name="postprocessing">
        <shader name="blur">
          <snippet type="version">330</snippet>
          <snippet type="string">
            <!--
        // out vec4 FragColor;
        // uniform sampler2D screenTexture;

        // void main()
        // {
        //     vec3 col = 4.0 / 16 * texelFetch(screenTexture, ivec2(gl_FragCoord.xy), 0).xyz;
        //     col += 2.0/16 *  texelFetch(screenTexture, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0).xyz;
        //     col += 2.0/16 *  texelFetch(screenTexture, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;
        //     col += 2.0/16 *  texelFetch(screenTexture, ivec2(gl_FragCoord.xy + vec2(0,1)), 0).xyz;
        //     col += 2.0/16 *  texelFetch(screenTexture, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;
        //     col += 1.0/16 *  texelFetch(screenTexture, ivec2(gl_FragCoord.xy + vec2(-1,-1)), 0).xyz;
        //     col += 1.0/16 *  texelFetch(screenTexture, ivec2(gl_FragCoord.xy + vec2(1,-1)), 0).xyz;
        //     col += 1.0/16 *  texelFetch(screenTexture, ivec2(gl_FragCoord.xy + vec2(-1,1)), 0).xyz;
        //     col += 1.0/16 *  texelFetch(screenTexture, ivec2(gl_FragCoord.xy + vec2(1,1)), 0).xyz;
        //     FragColor = vec4(col, 1.0);
        // }

        out vec4 FragColor;
        uniform sampler2D screenTexture;

        uniform bool horizontal;
        uniform float weight[5] = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);

        void main()
        {             
        vec4 resultv4 = texelFetch(screenTexture, ivec2(gl_FragCoord.xy), 0) * weight[0]; // current fragment's contribution
        if(resultv4 == vec4(0))
            discard;
        vec3 result = resultv4.rgb;
        if(horizontal)
        {
            for(int i = 1; i < 5; ++i)
            {
                result += texelFetch(screenTexture, ivec2(gl_FragCoord.xy + vec2(i,0)), 0).rgb * weight[i]; // current fragment's contribution
                result += texelFetch(screenTexture, ivec2(gl_FragCoord.xy + vec2(-i,0)), 0).rgb * weight[i]; // current fragment's contribution
            }
        }
        else
        {
            for(int i = 1; i < 5; ++i)
            {
                result += texelFetch(screenTexture, ivec2(gl_FragCoord.xy + vec2(0,i)), 0).rgb * weight[i]; // current fragment's contribution
                result += texelFetch(screenTexture, ivec2(gl_FragCoord.xy + vec2(0,-i)), 0).rgb * weight[i]; // current fragment's contribution
            }
        }
        FragColor = vec4(result, 1.0);
        }
            -->
            </snippet>
        </shader>
      </namespace>
</btf>