<?xml version="1.0" encoding="utf-8"?>
<btf type="MegaMolGLSLShader" version="1.0" namespace="contours">
    <include file="protein"/>
      <shader name="vertex">
        <snippet type="version">330</snippet>
        <snippet type="string">
        <!--
            layout (location = 0) in vec2 aPos;
            layout (location = 1) in vec2 aTexCoords;

            out vec2 TexCoords;

            void main()
            {
                TexCoords = aTexCoords;
                gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0); 
            }  
            -->
            </snippet>
        </shader>

      <shader name="fragmentOffscreen">
        <snippet type="version">330</snippet>
        <snippet type="string">
        <!--
            out vec4 FragColor;
            in vec2 TexCoords;
            uniform sampler2D screenTexture;

            void main()
            { 
                FragColor = texelFetch(screenTexture, ivec2(gl_FragCoord.xy), 0);
            }
            -->
            </snippet>
        </shader>

        <shader name="fragment">
          <snippet type="version">330</snippet>
          <snippet type="string">
            <!--
            out vec4 FragColor;
            in vec2 TexCoords;

            uniform sampler2D normalTexture;
            uniform sampler2D positionTexture;
            uniform sampler2D diffuseTexture;

            //parameter
            uniform int radius;
            uniform float neighbourThreshold; //percentage s in original  SC paper //  in original paper 0.2
            uniform float intensityDiffThreshold; //threshold d in original SC paper // in original paper 0.25
            uniform bool medianFilter;
            uniform bool circularNeighborhood;

            void main()
            {
                //total number of points according to radius [gauss circle problem]
                // int total;
                // if(radius == 1)
                //     total = 5;
                // else if(radius == 2)
                //     total = 13;
                // else if(radius == 3)
                //     total = 29;
                // else if(radius == 4)
                //     total = 49;
                // else if(radius == 5)
                //     total = 81;
                // else if(radius == 6)
                //     total = 113;
                // else if(radius == 7)
                //     total = 149;
                // else if(radius == 8)
                //     total = 197;
                // else if(radius == 9)
                //     total = 253;
                // else if(radius == 10)
                //     total = 317;

                vec3 normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy), 0).rgb;  
                if(normal == vec3(0.0)){
                    discard;
                }
                vec3 position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy), 0).rgb;
                vec3 lightdir = normalize(vec3(0.0, 0.0, 0.0) - position); 
                float col = dot(normal, lightdir);

                int darker = 0; //How many values are darker than the current pixel?
                float maxIntensity = col;
                
                float filterValues[100]; //Use biggest number as OpenGL does not allow variable sized arrays
                filterValues[0] = col;    //collects all values for median filtering. 
                                            //Incoming values are grayscale therefore r component is sufficient

                 
                // Loop over square with size radius * radius (use symmetry so only 1/4 needs to be tested).
                // Discard all points that are not part of the circle
                // Collect data and save all intensities to filterValues
                int idx = 1;
                int total = 1;
                vec3 cur_normal;
                vec3 cur_position;
                vec3 cur_lightdir;
                float cur;
                for(int x = 0; x <= radius; x++){
                    for(int y = 0; y <= radius; y++){
                        if(x == 0 && y == 0)
                            continue;
                        else if(circularNeighborhood && x*x + y*y > radius * radius){
                            continue;
                        }
                        else{
                            ++total;
                            cur_normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy) + ivec2(x,y), 0).rgb;
                            cur_position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(x,y), 0).rgb;
                            cur_lightdir = normalize(-cur_position);
                            cur = dot(cur_normal, cur_lightdir);
                            if(cur <= col)
                                ++darker;
                            if(cur > maxIntensity)
                                maxIntensity = cur;
                            filterValues[idx] = cur;
                            idx++;

                            if(x != 0){
                                ++total;
                                cur_normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy) + ivec2(-x,y), 0).rgb;
                                cur_position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(-x,y), 0).rgb;
                                cur_lightdir = normalize(-cur_position);
                                cur = dot(cur_normal, cur_lightdir);
                                if(cur <= col)
                                    ++darker;
                                if(cur > maxIntensity)
                                    maxIntensity = cur;
                                filterValues[idx] = cur;
                                idx++;
                                
                                if(y != 0){
                                    ++total;
                                    cur_normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy) + ivec2(-x,-y), 0).rgb;
                                    cur_position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(-x,-y), 0).rgb;
                                    cur_lightdir = normalize(-cur_position);
                                    cur = dot(cur_normal, cur_lightdir);
                                    if(cur <= col)
                                        ++darker;
                                    if(cur > maxIntensity)
                                        maxIntensity = cur;
                                    filterValues[idx] = cur;
                                    idx++;
                                }
                            }

                            if(y!= 0){
                                ++total;
                                cur_normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy) + ivec2(x,-y), 0).rgb;
                                cur_position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(x,-y), 0).rgb;
                                cur_lightdir = normalize(-cur_position);
                                cur = dot(cur_normal, cur_lightdir);
                                if(cur <= col)
                                    ++darker;
                                if(cur > maxIntensity)
                                    maxIntensity = cur;
                                filterValues[idx] = cur;
                                idx++;
                            }

                        }
                    }
                }
                if(darker > neighbourThreshold * total){
                    discard;
                }
                if(maxIntensity - col <= intensityDiffThreshold){
                    discard;
                }

                // //Median filtering
                if(medianFilter){
                    for(int n = total-1; n > 0; n = n - 1){
                        for(int i = 0; i < n; ++i){
                            float minimum = min(filterValues[i], filterValues[i+1]);
                            filterValues[i+1] = max(filterValues[i], filterValues[i+1]);
                            filterValues[i] = minimum;
                        }
                    }
                    // assign col to the median
                    col = filterValues[int(floor(total * 1.0 / 2.0))];
                }

                col = 1.0 - col; //invert color because background is dark

                FragColor = vec4(col, col, col, 1.0);
            }
          -->
        </snippet>
      </shader>

        <shader name="curvature">
          <snippet type="version">330</snippet>
          <snippet type="string">
            <!--


            out vec4 fragCurvature;

            uniform sampler2D tex_fragPosition;
            uniform sampler2D tex_fragNormal;


            void main() {
                vec4 passPosition_view = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy), 0);
                vec4 passNormal_view = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy), 0);

                vec3 n = normalize(passNormal_view.xyz);

                vec3 pixelPositionLeft = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0).xyz;
                vec3 pixelPositionTop = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;
                vec3 pixelPositionRight = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;
                vec3 pixelPositionBottom = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,1)), 0).xyz;

                // Compute curvature
                vec3 dx = dFdx(n) / length(pixelPositionLeft - pixelPositionRight); // Das ist zur Normalisierung, da man nicht weiß wie weit die einzelnen Pixel im view space tatsächlich auseinander liegen und man schlussendlich in jedem fragemnt shader Lauf gleiche Abstände haben möchte
                vec3 dy = dFdy(n) / length(pixelPositionTop - pixelPositionBottom);
                vec3 xneg = n - dx;//Das hier sind dann quasi die neuen ein bisschen verschobenen Normalen aber äquivalente Abstände für alle fragment shader läufe
                vec3 xpos = n + dx;
                vec3 yneg = n - dy;
                vec3 ypos = n + dy;
                float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x);

                fragCurvature = vec4(vec3(curvature), 1.0);
            }
            -->
            </snippet>
        </shader>

        <shader name="normalCurvature">
          <snippet type="version">330</snippet>
          <snippet type="string">
            <!--


            out vec4 fragCurvature;

            uniform sampler2D tex_fragPosition;
            uniform sampler2D tex_fragNormal;


            void main() {
                vec4 passPosition_view = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy), 0);
                vec4 passNormal_view = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy), 0);

                vec3 n = normalize(passNormal_view.xyz);

                vec3 pixelPositionLeft = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0).xyz;
                vec3 pixelPositionTop = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;
                vec3 pixelPositionRight = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;
                vec3 pixelPositionBottom = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,1)), 0).xyz;

                // Compute curvature
                vec3 dx = dFdx(n) / length(pixelPositionLeft - pixelPositionRight); // Das ist zur Normalisierung, da man nicht weiß wie weit die einzelnen Pixel im view space tatsächlich auseinander liegen und man schlussendlich in jedem fragemnt shader Lauf gleiche Abstände haben möchte
                vec3 dy = dFdy(n) / length(pixelPositionTop - pixelPositionBottom);
                vec3 xneg = n - dx;//Das hier sind dann quasi die neuen ein bisschen verschobenen Normalen aber äquivalente Abstände für alle fragment shader läufe
                vec3 xpos = n + dx;
                vec3 yneg = n - dy;
                vec3 ypos = n + dy;
                float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x);

                fragCurvature = vec4(vec3(curvature), 1.0);
            }
            -->
            </snippet>
        </shader>
        
        <shader name="SCcurvature">
          <snippet type="version">330</snippet>
          <snippet type="string">
            <!--
            out vec4 fragCurvature;

            uniform sampler2D tex_fragPosition;
            uniform sampler2D tex_fragCurvature;
            uniform sampler2D tex_fragNormal;

            vec4 showZerocrossing(float curvature, float curvatureDxy) {
                if(abs(curvature) <= 0.01 * curvatureDxy) {
                    return vec4(0);
                }
                return vec4(1);
            }

            void main() {
                vec3 pixelPosition = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy), 0).xyz;
                vec3 pixelNormal = normalize(texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy), 0).xyz);
                vec4 curvature = texelFetch(tex_fragCurvature, ivec2(gl_FragCoord.xy), 0);

                // if (curvature.xyz == vec3(1, 0, 0)) { // "Maske"
                //     fragCurvature=vec4(1);
                // }

                float f = 1.0;//0.01;
                float scaledCurvature = curvature.x * f;

                // TODO: use pixel 3D locations to calculate the derivative. Also smooth the result -> pull-push
                vec3 pixelPositionLeft = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0).xyz;
                vec3 pixelPositionTop = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;
                vec3 pixelPositionRight = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;
                vec3 pixelPositionBottom = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,1)), 0).xyz;

                float curvatureDx = dFdx(scaledCurvature); // / length(pixelPositionLeft - pixelPositionRight);
                float curvatureDy = dFdy(scaledCurvature); // / length(pixelPositionTop - pixelPositionBottom);
                vec2 curvatureDirection = (vec2(curvatureDx, curvatureDy));

                // create local coordinate system at the pixel position
                vec3 h = normalize(vec3(-1));
                vec3 U = cross(pixelNormal, h);
                vec3 V = cross(h, U);

                // project the view vector into the local system
                vec3 v = normalize(-pixelPosition);
                vec2 vProjected = vec2(dot(U,v), dot (V,v));

                float isSuggestiveContour = sign(dot(vProjected, curvatureDirection));

                if (scaledCurvature >= 0) {
                    fragCurvature = vec4(1) - vec4(scaledCurvature, 0, 0, 0);
                } else {
                    fragCurvature = vec4(1) - vec4(0, -scaledCurvature, 0, 0);
                }

                if(isSuggestiveContour > 0) {
                    fragCurvature *= showZerocrossing(scaledCurvature, length(curvatureDirection));
                }

            }
          -->
        </snippet>
      </shader>
</btf>