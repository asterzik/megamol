<?xml version="1.0" encoding="utf-8"?>
<btf type="MegaMolGLSLShader" version="1.0" namespace="contours">
    <include file="protein"/>
      <shader name="vertex">
        <snippet type="version">330</snippet>
        <snippet type="string">
        <!--
            layout (location = 0) in vec2 aPos;
            layout (location = 1) in vec2 aTexCoords;

            out vec2 TexCoords;

            void main()
            {
                TexCoords = aTexCoords;
                gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0); 
            }  
            -->
            </snippet>
        </shader>

      <shader name="passThrough">
        <snippet type="version">330</snippet>
        <snippet type="string">
        <!--
            out vec4 FragColor;
            in vec2 TexCoords;
            uniform sampler2D screenTexture;

            void main()
            { 
                vec4 color = texelFetch(screenTexture, ivec2(gl_FragCoord.xy), 0);
                if(color.a == 0)
                    discard;
                FragColor = color;
            }
            -->
            </snippet>
        </shader>
      <shader name="curvatureDiff">
        <snippet type="version">330</snippet>
        <snippet type="string">
        <!--
            out vec4 FragColor;
            in vec2 TexCoords;
            uniform sampler2D exactTexture;
            uniform sampler2D approxTexture;

            void main()
            { 
                vec4 exact = texelFetch(exactTexture, ivec2(gl_FragCoord.xy), 0);
                if(exact.a == 0)
                    discard;
                vec4 approx = texelFetch(approxTexture, ivec2(gl_FragCoord.xy), 0);
                FragColor = vec4(vec3(exact.x - approx.x), 1.0);
            }
            -->
            </snippet>
        </shader>
      <shader name="colormap">
        <snippet type="version">330</snippet>
        <snippet type="string">
        <!--
            out vec4 FragColor;
            in vec2 TexCoords;
            uniform sampler2D screenTexture;
            uniform sampler2D widthTexture;
            uniform int level_max;
            
            //colormap code from: https://github.com/kbinani/colormap-shaders/blob/master/shaders/glsl/IDL_CB-PiYG.frag
            float colormap_red(float x) {
                if (x < 0.09843078255653381) {
                    return 5.57627692307694E+02 * x + 1.42135384615385E+02;
                } else if (x < 0.4093809425830841) {
                    return ((-4.21748915649019E+02 * x + 1.28054196831998E+01) * x + 2.64504106766935E+02) * x + 1.71265909327078E+02;
                } else if (x < 0.5037343473981705) {
                    return -6.54538461538185E+01 * x + 2.79554615384612E+02;
                } else if (x < 0.5982368290424347) {
                    return -1.66852258852308E+02 * x + 3.30632478632496E+02;
                } else {
                    return ((1.82001891024969E+03 * x - 4.20447326861499E+03) * x + 2.68838861198902E+03) * x - 2.62418693972160E+02;
                }
            }

            float colormap_green(float x) {
                if (x < 0.101902037858963) {
                    return 2.72322735042735E+02 * x + 5.21367521367536E-01;
                } else if (x < 0.5059849917888641) {
                    return ((6.81035433115437E+02 * x - 1.71408042362240E+03) * x + 1.36671536460816E+03) * x - 9.39210546594673E+01;
                } else if (x < 0.5954320132732391) {
                    return -2.72768472906136E+01 * x + 2.60800985221660E+02;
                } else {
                    return ((1.09164194296742E+03 * x - 3.01508808799416E+03) * x + 2.33004497173996E+03) * x - 3.04306745740377E+02;
                }
            }

            float colormap_blue(float x) {
                if (x < 0.5011215507984161) {
                    return (((((-3.44764954376220E+04 * x + 6.98813026428223E+04) * x - 4.87748659515380E+04) * x + 1.31832279253005E+04) * x - 1.26691288614273E+03) * x + 4.73465709444135E+02) * x + 8.21916531938477E+01;
                } else if (x < 0.5958432303492089) {
                    return -3.80379731379794E+02 * x + 4.37472934472961E+02;
                } else if (x < 0.790071576833725) {
                    return -7.13383710407293E+02 * x + 6.35891101055846E+02;
                } else {
                    return (1.19760697610430E+03 * x - 2.36001183205723E+03) * x + 1.18928322234544E+03;
                }
            }

            vec4 colormap(float x) {
                float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);
                float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);
                float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);
                return vec4(r, g, b, 1.0);
            }
            void main()
            { 
                vec4 color = texelFetch(screenTexture, ivec2(gl_FragCoord.xy), 0);
                if(color.a == 0)
                    discard;
                vec2 width = texelFetch(widthTexture, ivec2(0,0), level_max - 1).xy;
                float maximum = 1;
                float minimum = -maximum;//width.y;
                float scaled = (color.x - minimum)/(maximum - minimum);
                FragColor = colormap(scaled);
            }
            -->
            </snippet>
        </shader>
      <shader name="normalizePositions">
        <snippet type="version">330</snippet>
        <snippet type="string">
        <!--
            out vec4 FragColor;
            in vec2 TexCoords;
            uniform sampler2D positionTexture;
            uniform sampler2D depthTexture;
            uniform sampler2D heightTexture;
            uniform sampler2D widthTexture;
            uniform int level_max;

            void main()
            { 
                vec4 position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy), 0);
                if(position == vec4(0.0))
                    discard;
                vec2 depth = texelFetch(depthTexture, ivec2(0,0), level_max - 1).xy;
                vec2 height = texelFetch(heightTexture, ivec2(0,0), level_max - 1).xy;
                vec2 width = texelFetch(widthTexture, ivec2(0,0), level_max - 1).xy;

                vec3 mins = vec3(width.y, height.y, depth.y);
                vec3 maxs = vec3(width.x, height.x, depth.x);

                vec3 intensity;
                intensity = (position.xyz - mins) / (maxs - mins);
                FragColor = vec4(intensity, 1.0);
            }

            -->
            </snippet>
        </shader>

        <namespace name="contours">
        <shader name="SC">
          <snippet type="version">330</snippet>
          <snippet type="string">
            <!--
            out vec4 FragColor;
            in vec2 TexCoords;

            uniform sampler2D normalTexture;
            uniform sampler2D positionTexture;

            //parameter
            uniform int radius;
            uniform float neighbourThreshold; //percentage s in original  SC paper //  in original paper 0.2
            uniform float intensityDiffThreshold; //threshold d in original SC paper // in original paper 0.25
            uniform bool medianFilter;
            uniform bool circularNeighborhood;
            uniform bool whiteBackground;

            void main()
            {

                vec3 normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy), 0).rgb;  
                if(normal == vec3(0.0)){
                    discard;
                }
                vec3 position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy), 0).rgb;
                vec3 lightdir;
                    lightdir = normalize(vec3(0.0, 0.0, 0.0) - position); 
                float col = dot(normal, lightdir);

                int darker = 0; //How many values are darker than the current pixel?
                float maxIntensity = col;
                
                float filterValues[100]; //Use biggest number as OpenGL does not allow variable sized arrays
                filterValues[0] = col;    //collects all values for median filtering. 
                                            //Incoming values are grayscale therefore r component is sufficient

                 
                // Loop over square with size radius * radius (use symmetry so only 1/4 needs to be tested).
                // Discard all points that are not part of the circle
                // Collect data and save all intensities to filterValues
                int idx = 1;
                int total = 1;
                vec3 cur_normal;
                vec3 cur_position;
                float cur;
                for(int x = 0; x <= radius; x++){
                    for(int y = 0; y <= radius; y++){
                        if(x == 0 && y == 0)
                            continue;
                        else if(circularNeighborhood && x*x + y*y > radius * radius){
                            continue;
                        }
                        else{
                            ++total;
                            cur_normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy) + ivec2(x,y), 0).rgb;
                            cur_position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(x,y), 0).rgb;
                                lightdir = normalize(-cur_position);
                            cur = dot(cur_normal, lightdir);
                            if(cur <= col)
                                ++darker;
                            if(cur > maxIntensity)
                                maxIntensity = cur;
                            filterValues[idx] = cur;
                            idx++;

                            if(x != 0){
                                ++total;
                                cur_normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy) + ivec2(-x,y), 0).rgb;
                                cur_position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(-x,y), 0).rgb;
                                    lightdir = normalize(-cur_position);
                                cur = dot(cur_normal, lightdir);
                                if(cur <= col)
                                    ++darker;
                                if(cur > maxIntensity)
                                    maxIntensity = cur;
                                filterValues[idx] = cur;
                                idx++;
                                
                                if(y != 0){
                                    ++total;
                                    cur_normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy) + ivec2(-x,-y), 0).rgb;
                                    cur_position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(-x,-y), 0).rgb;
                                        lightdir = normalize(-cur_position);
                                    cur = dot(cur_normal, lightdir);
                                    if(cur <= col)
                                        ++darker;
                                    if(cur > maxIntensity)
                                        maxIntensity = cur;
                                    filterValues[idx] = cur;
                                    idx++;
                                }
                            }

                            if(y!= 0){
                                ++total;
                                cur_normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy) + ivec2(x,-y), 0).rgb;
                                cur_position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(x,-y), 0).rgb;
                                    lightdir = normalize(-cur_position);
                                cur = dot(cur_normal, lightdir);
                                if(cur <= col)
                                    ++darker;
                                if(cur > maxIntensity)
                                    maxIntensity = cur;
                                filterValues[idx] = cur;
                                idx++;
                            }

                        }
                    }
                }
                if(darker > neighbourThreshold * total){
                    discard;
                }
                if(maxIntensity - col <= intensityDiffThreshold){
                    discard;
                }

                // //Median filtering
                if(medianFilter){
                    for(int n = total-1; n > 0; n = n - 1){
                        for(int i = 0; i < n; ++i){
                            float minimum = min(filterValues[i], filterValues[i+1]);
                            filterValues[i+1] = max(filterValues[i], filterValues[i+1]);
                            filterValues[i] = minimum;
                        }
                    }
                    // assign col to the median
                    col = filterValues[int(floor(total * 1.0 / 2.0))];
                }

                if(!whiteBackground)
                    col = 1.0 - col; //invert color because background is dark

                FragColor = vec4(col, col, col, 1.0);
            }
          -->
        </snippet>
      </shader>

        <shader name="SC_Curvature">
          <snippet type="version">330</snippet>
          <snippet type="string">
            <!--
            //This is not really working. When the curvature is high for an object, the values inside the sphere are varying strongly such that the intensityDiffThreshold does not catch them anymore.
            out vec4 FragColor;
            in vec2 TexCoords;

            uniform sampler2D normalTexture;
            uniform sampler2D positionTexture;
            uniform sampler2D curvatureTexture;

            //parameter
            uniform int radius;
            uniform float neighbourThreshold; //percentage s in original  SC paper //  in original paper 0.2
            uniform float intensityDiffThreshold; //threshold d in original SC paper // in original paper 0.25
            uniform float cutOff;
            uniform bool medianFilter;
            uniform bool circularNeighborhood;
            uniform bool whiteBackground;

            void main()
            {
                vec3 normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy), 0).rgb;  
                if(normal == vec3(0.0)){
                    discard;
                }
                vec3 position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy), 0).rgb;
                float curvature = texelFetch(curvatureTexture, ivec2(gl_FragCoord.xy), 0).r;
                // vec3 lightdir = normalize(vec3(0.0, 0.0, 0.0) - position); 
                vec3 lightdir =vec3(0.0, 0.0, 1.0); 
                float col = dot(normal, lightdir);
                col /= sqrt(cutOff * abs(curvature) * (2 - cutOff * abs(curvature)));

                int darker = 0; //How many values are darker than the current pixel?
                float maxIntensity = col;
                
                float filterValues[100]; //Use biggest number as OpenGL does not allow variable sized arrays
                filterValues[0] = col;    //collects all values for median filtering. 
                                            //Incoming values are grayscale therefore r component is sufficient

                 
                // Loop over square with size radius * radius (use symmetry so only 1/4 needs to be tested).
                // Discard all points that are not part of the circle
                // Collect data and save all intensities to filterValues
                int idx = 1;
                int total = 1;
                vec3 cur_normal;
                vec3 cur_position;
                float cur_curvature;
                float cur;
                for(int x = 0; x <= radius; x++){
                    for(int y = 0; y <= radius; y++){
                        if(x == 0 && y == 0)
                            continue;
                        else if(circularNeighborhood && x*x + y*y > radius * radius){
                            continue;
                        }
                        else{
                            ++total;
                            cur_normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy) + ivec2(x,y), 0).rgb;
                            cur_position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(x,y), 0).rgb;
                            cur_curvature = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(x,y), 0).z;
                            cur = dot(cur_normal, lightdir);
                            cur /= sqrt(cutOff * abs(cur_curvature) * (2 - cutOff * abs(cur_curvature)));
                            if(cur <= col)
                                ++darker;
                            if(cur > maxIntensity)
                                maxIntensity = cur;
                            filterValues[idx] = cur;
                            idx++;

                            if(x != 0){
                                ++total;
                                cur_normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy) + ivec2(-x,y), 0).rgb;
                                cur_position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(-x,y), 0).rgb;
                                cur_curvature = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(-x,y), 0).z;
                                cur = dot(cur_normal, lightdir);
                                cur /= sqrt(cutOff * abs(cur_curvature) * (2 - cutOff * abs(cur_curvature)));
                                if(cur <= col)
                                    ++darker;
                                if(cur > maxIntensity)
                                    maxIntensity = cur;
                                filterValues[idx] = cur;
                                idx++;
                                
                                if(y != 0){
                                    ++total;
                                    cur_normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy) + ivec2(-x,-y), 0).rgb;
                                    cur_position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(-x,-y), 0).rgb;
                                    cur_curvature = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(-x,-y), 0).z;
                                    cur = dot(cur_normal, lightdir);
                                    cur /= sqrt(cutOff * abs(cur_curvature) * (2 - cutOff * abs(cur_curvature)));
                                    if(cur <= col)
                                        ++darker;
                                    if(cur > maxIntensity)
                                        maxIntensity = cur;
                                    filterValues[idx] = cur;
                                    idx++;
                                }
                            }

                            if(y!= 0){
                                ++total;
                                cur_normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy) + ivec2(x,-y), 0).rgb;
                                cur_position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(x,-y), 0).rgb;
                                cur_curvature = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(x,-y), 0).z;
                                cur = dot(cur_normal, lightdir);
                                cur /= sqrt(cutOff * abs(cur_curvature) * (2 - cutOff * abs(cur_curvature)));
                                if(cur <= col)
                                    ++darker;
                                if(cur > maxIntensity)
                                    maxIntensity = cur;
                                filterValues[idx] = cur;
                                idx++;
                            }

                        }
                    }
                }
                if(darker > neighbourThreshold * total){
                    discard;
                }
                if(maxIntensity - col <= intensityDiffThreshold){
                    discard;
                }
                // //Median filtering
                if(medianFilter){
                    for(int n = total-1; n > 0; n = n - 1){
                        for(int i = 0; i < n; ++i){
                            float minimum = min(filterValues[i], filterValues[i+1]);
                            filterValues[i+1] = max(filterValues[i], filterValues[i+1]);
                            filterValues[i] = minimum;
                        }
                    }
                    // assign col to the median
                    col = filterValues[int(floor(total * 1.0 / 2.0))];
                }

                if(!whiteBackground)
                    col = 1.0 - col; //invert color because background is dark

                FragColor = vec4(col, col, col, 1.0);
            }
          -->
        </snippet>
      </shader>
        <shader name="C">
          <snippet type="version">330</snippet>
          <snippet type="string">
            <!--
            out vec4 FragColor;
            in vec2 TexCoords;

            uniform sampler2D normalTexture;
            uniform sampler2D positionTexture;
            uniform sampler2D shadingTexture;
            uniform float cutOff;
            uniform int level_max;
            uniform int viewType;
            uniform bool whiteBackground;
            uniform bool overlay;

            void main()
            {
                vec3 normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy), 0).rgb;  
                if(normal == vec3(0.0)){
                    discard;
                }
                vec3 position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy), 0).rgb;
                vec3 lightdir;
                float col;
                if(viewType == 0){
                    lightdir = vec3(0.0,0.0,1.0);
                }
                else{
                    lightdir = normalize(vec3(0.0, 0.0, 0.0) - position); 
                }
                col = dot(normal, lightdir);
                if(col > cutOff){
                    if(overlay) FragColor = texelFetch(shadingTexture, ivec2(gl_FragCoord.xy), 0);
                    else discard;
                }
                else{
                    if(whiteBackground || overlay){
                        FragColor = vec4(vec3(0.0), 1.0);
                    }
                    else{
                        FragColor = vec4(vec3(1.0), 1.0);
                    }
                }

            }
          -->
        </snippet>
      </shader>
        <shader name="C_Curvature">
          <snippet type="version">330</snippet>
          <snippet type="string">
            <!--
            out vec4 FragColor;
            in vec2 TexCoords;

            uniform sampler2D normalTexture;
            uniform sampler2D positionTexture;
            uniform sampler2D curvatureTexture;
            uniform sampler2D shadingTexture;
            uniform int level_max;
            uniform float cutOff;
            uniform int viewType;
            
            uniform float near_plane;
            uniform bool whiteBackground;
            uniform bool overlay;

            void main()
            {
                vec4 position = texelFetch(positionTexture, ivec2(gl_FragCoord.xy), 0);
                vec3 normal = texelFetch(normalTexture, ivec2(gl_FragCoord.xy), 0).rgb;  
                if(normal == vec3(0.0) || position.a == 0){
                    discard;
                }
                else{
                vec3 lightdir;
                float col, curvature;
                curvature = texelFetch(curvatureTexture, ivec2(gl_FragCoord.xy), 0).r;
                //orthogonal projection
                if(viewType == 0){
                    lightdir = vec3(0.0,0.0,1.0);
                }
                //perspective projection
                else{
                    lightdir = normalize(vec3(0.0, 0.0, 0.0) - position.xyz); 
                    // curvature *= (position.z / near_plane);
                }
                col =dot(normal, lightdir);
                vec3 right = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(0,1), 0).rgb;
                vec3 left = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) - ivec2(0,1), 0).rgb;
                vec3 up = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) + ivec2(1,0), 0).rgb;
                vec3 down = texelFetch(positionTexture, ivec2(gl_FragCoord.xy) - ivec2(1,0), 0).rgb;
                float d1,d2,d3,d4;
                d1 = length(position.xyz - right);
                d2 = length(position.xyz - left);
                d3 = length(position.xyz - up);
                d4 = length(position.xyz - down);
                // float viewSpaceWidth = min(min(d1,d2),min(d3,d4));
                // float viewSpaceWidth = (length(position.xyz - right) + length(position.xyz - left) + length(position.xyz - up) + length(position.xyz -down))/4;
                float viewSpaceWidth = 0.5*(min(d1,d2)+min(d3,d4));
                float C = cutOff * viewSpaceWidth;
                if(col > sqrt(C * abs(curvature) * (2 - C * abs(curvature)))){
                    if(overlay) FragColor = texelFetch(shadingTexture, ivec2(gl_FragCoord.xy), 0);
                    else{ discard;}
                }
                else{
                if(whiteBackground || overlay){
                    FragColor = vec4(vec3(0.0), 1.0);
                }
                else{
                    FragColor = vec4(vec3(1.0), 1.0);
                }
                }
                }
            }
          -->
        </snippet>
      </shader>
      </namespace>

        <namespace name="curvature">
        <shader name="evans">
          <snippet type="version">450</snippet>
          <snippet type="string">
            <!--


            out vec4 fragCurvature;

            uniform sampler2D tex_fragPosition;
            uniform sampler2D tex_fragNormal;


            void main() {
                vec4 passPosition_view = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy), 0);
                vec4 passNormal_view = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy), 0);
                if(passPosition_view == vec4(0.0))
                    discard;

                vec3 n = normalize(passNormal_view.xyz);

                vec3 pixelPositionLeft = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0).xyz;
                vec3 pixelPositionTop = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,1)), 0).xyz;
                vec3 pixelPositionRight = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;
                vec3 pixelPositionBottom = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;

                // Compute curvature
                vec3 dx = dFdx(n);
                    dx /= length(pixelPositionLeft - pixelPositionRight); // Das ist zur Normalisierung, da man nicht weiß wie weit die einzelnen Pixel im view space tatsächlich auseinander liegen und man schlussendlich in jedem fragemnt shader Lauf gleiche Abstände haben möchte
                vec3 dy = dFdy(n);
                    dy /= length(pixelPositionTop - pixelPositionBottom);
                vec3 xneg = n - dx;//Das hier sind dann quasi die neuen ein bisschen verschobenen Normalen aber äquivalente Abstände für alle fragment shader läufe
                vec3 xpos = n + dx;
                vec3 yneg = n - dy;
                vec3 ypos = n + dy;
                float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x);
                if(isnan(curvature))
                    discard;

                fragCurvature = vec4(vec3(-curvature), 1.0);
            }
            -->
            </snippet>
        </shader>

        <shader name="mean">
          <snippet type="version">330</snippet>
          <snippet type="string">
            <!--


            out vec4 fragCurvature;

            uniform sampler2D tex_fragPosition;
            uniform sampler2D tex_fragNormal;


            void main() {
                vec4 passPosition_view = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy), 0);
                vec4 passNormal_view = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy), 0);
                if(passPosition_view == vec4(0.0))
                    discard;

                vec3 n = normalize(passNormal_view.xyz);

                vec3 pLeft = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0).xyz;
                vec3 pTop = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,1)), 0).xyz;
                vec3 pRight = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;
                vec3 pBottom = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;

                vec3 dx = dFdx(n) / length(pLeft - pRight); // Das ist zur Normalisierung, da man nicht weiß wie weit die einzelnen Pixel im view space tatsächlich auseinander liegen und man schlussendlich in jedem fragemnt shader Lauf gleiche Abstände haben möchte
                vec3 dy = dFdy(n) / length(pTop - pBottom);
                
                float curvature = (-(dx.x + dy.y)/n.z + (n.x * dx.z + n.y * dy.z) / (n.z * n.z)) / -2;
                if(isnan(curvature)) //This happens at the silhouette of the molecule, because for the calculation of dFdx or dFdy, neighbouring pixels are vec4(0).
                    discard;

                fragCurvature = vec4(vec3(curvature), 1.0);
                // if(length(pLeft-pRight) < 0.1)
                //     fragCurvature = vec4(vec3(0.8118, 0.8, 0.0275), 1.0);
                // if(length(pTop-pBottom) < 0.1)
                //     fragCurvature = vec4(vec3(0.9451, 0.298, 0.7843), 1.0);
            }
            -->
            </snippet>
        </shader>

        <shader name="normal">
          <snippet type="version">330</snippet>
          <snippet type="string">
            <!--
            out vec4 fragCurvature;

            uniform sampler2D tex_fragPosition;
            uniform sampler2D tex_fragNormal;


            void main() {
                vec4 passPosition_view = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy), 0);
                vec4 passNormal_view = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy), 0);
                if(passPosition_view == vec4(0.0))
                    discard;

                vec3 p = passPosition_view.xyz;
                vec3 n = normalize(passNormal_view.xyz);


                vec3 pLeft = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0).xyz;
                vec3 pTop = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,1)), 0).xyz;
                vec3 pRight = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;
                vec3 pBottom = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;

                float curvatureLeft = dot(n, p - pLeft) / (length(p-pLeft) * length(p-pLeft));
                float curvatureTop = dot(n , p - pTop) / (length(pTop - p) * length(pTop - p));
                float curvatureRight = dot(n, p - pRight) / (length(pRight - p) * length(pRight - p));
                float curvatureBottom = dot(n, p - pBottom) / (length(pBottom - p) * length(pBottom - p));

                float curvature = (curvatureLeft + curvatureTop + curvatureRight + curvatureBottom) / 4;
                fragCurvature = vec4(vec3(curvature), 1.0);
            }


            -->
            </snippet>
        </shader>
        <shader name="normal_averaged">
          <snippet type="version">330</snippet>
          <snippet type="string">
            <!--


            out vec4 fragCurvature;

            uniform sampler2D tex_fragPosition;
            uniform sampler2D tex_fragNormal;


            void main() {
                vec4 passPosition_view = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy), 0);
                vec4 passNormal_view = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy), 0);
                if(passPosition_view == vec4(0.0))
                    discard;

                vec3 p = passPosition_view.xyz;
                vec3 n = normalize(passNormal_view.xyz);

                vec3 pLeft = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0).xyz;
                vec3 pTop = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,1)), 0).xyz;
                vec3 pRight = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;
                vec3 pBottom = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;

                vec3 nLeft = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0).xyz;
                vec3 nTop = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;
                vec3 nRight = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;
                vec3 nBottom = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(0,1)), 0).xyz;

                // Compute curvature for all "edges" in the 4-neighborhood
                float curvatureLeft = dot(n - nLeft, p - pLeft) / (length(p-pLeft) * length(p-pLeft));
                float curvatureTop = dot(n- nTop, p - pTop) / (length(pTop - p) * length(pTop - p));
                float curvatureRight = dot(n -nRight, p - pRight) / (length(pRight - p) * length(pRight - p));
                float curvatureBottom = dot(n -nBottom, p - pBottom) / (length(pBottom - p) * length(pBottom - p));

                float curvature = (curvatureLeft + curvatureTop + curvatureRight + curvatureBottom) / 4;

                fragCurvature = vec4(vec3(curvature), 1.0);
            }
            -->
            </snippet>
        </shader>
        <shader name="prantlmean">
          <snippet type="version">420</snippet>
          <snippet type="string">
            <!--
			#define TRIANGLE_VERTICES  3


            out vec4 fragCurvature;

            uniform sampler2D tex_fragPosition;
            uniform sampler2D tex_fragNormal;

//Begin

			vec2 CalcCurvature_ShapeOperator(vec3 a, vec3 b, vec3 c, vec3 an, vec3 bn, vec3 cn)
			{
	
				vec3 local_trianglePos[TRIANGLE_VERTICES];
				vec3 local_triangleNor[TRIANGLE_VERTICES];

	
				//=========================================================================================================

				vec3 _ba_ = (b - a);
				vec3 _ca_ = (c - a);

	
	
				vec3 axis[TRIANGLE_VERTICES];
				axis[0] = normalize(_ba_);
				axis[2] = normalize(cross(axis[0], _ca_));    
				axis[1] = normalize(cross(axis[0], axis[2]));
				
				// mat3 transformMatrix = mat3(axis[0], axis[1], axis[2]);  
                // transformMatrix = transpose(transformMatrix);
                mat3 transformMatrix = mat3(axis[0][0], axis[1][0], axis[2][0],
                                            axis[0][1], axis[1][1], axis[2][1],
                                            axis[0][2], axis[1][2], axis[2][2]);
				
				local_trianglePos[0] = vec3(0,0,0);
				local_triangleNor[0] = transformMatrix * an;
	
				local_trianglePos[1] = transformMatrix * _ba_;	
				local_triangleNor[1] = transformMatrix * bn;

				local_trianglePos[2] = transformMatrix * _ca_;	
				local_triangleNor[2] = transformMatrix * cn;
	
				vec3 u;
				vec3 v;

				vec3 du;
				vec3 dv;

				u.x = local_trianglePos[1].x - local_trianglePos[0].x;
				u.y = local_trianglePos[2].x - local_trianglePos[1].x;
				u.z = local_trianglePos[0].x - local_trianglePos[2].x;

				v.x = local_trianglePos[1].y - local_trianglePos[0].y;
				v.y = local_trianglePos[2].y - local_trianglePos[1].y;
				v.z = local_trianglePos[0].y - local_trianglePos[2].y;
	

				du.x = local_triangleNor[1].x - local_triangleNor[0].x;
				du.y = local_triangleNor[2].x - local_triangleNor[1].x;
				du.z = local_triangleNor[0].x - local_triangleNor[2].x;

				dv.x = local_triangleNor[1].y - local_triangleNor[0].y;
				dv.y = local_triangleNor[2].y - local_triangleNor[1].y;	
				dv.z = local_triangleNor[0].y - local_triangleNor[2].y;
	
				//===============================================================================


				
				//inverse of 3x3 matrix
				//invB = inverse of B

				float aa = dot(u, u);
				float bb = dot(u, v);
				float cc = dot(v, v);

				float invB_B = -(bb * cc);
				float invB_C =  (bb * bb);
				float invB_D =  (aa * cc);
				float invB_E = -(aa * bb);
				float invB_A = -invB_C + (cc * cc) + invB_D;
				float invB_F =  (aa * aa) + invB_D - invB_C;

				float determinantB = 1.0 / ((aa + cc) * (invB_D - invB_C));

				//=======================================================================================

				//col based matrices
				mat3 resLeft;
				mat3 resRight;
	
				resLeft[0][0] = v.x * invB_B + u.x * invB_A;
				resLeft[0][1] = v.x * invB_C + u.x * invB_B;
				resLeft[0][2] = v.y * invB_B + u.y * invB_A;
				resRight[0][0] = v.y * invB_C + u.y * invB_B;
				resRight[0][1] = v.z * invB_B + u.z * invB_A;
				resRight[0][2] = v.z * invB_C + u.z * invB_B;

				resLeft[1][0] = v.x * invB_D + u.x * invB_B;
				resLeft[1][1] = v.x * invB_E + u.x * invB_D;
				resLeft[1][2] = v.y * invB_D + u.y * invB_B;
				resRight[1][0] = v.y * invB_E + u.y * invB_D;
				resRight[1][1] = v.z * invB_D + u.z * invB_B;
				resRight[1][2] = v.z * invB_E + u.z * invB_D;

				resLeft[2][0] = v.x * invB_E + u.x * invB_C;
				resLeft[2][1] = v.x * invB_F + u.x * invB_E;
				resLeft[2][2] = v.y * invB_E + u.y * invB_C;
				resRight[2][0] = v.y * invB_F + u.y * invB_E;
				resRight[2][1] = v.z * invB_E + u.z * invB_C;
				resRight[2][2] = v.z * invB_F + u.z * invB_E;

				//================================================================================
				
				vec3 finalM_gpu_a = vec3(du.x, dv.x, du.y) * resLeft;
				vec3 finalM_gpu_b = vec3(dv.y, du.z, dv.z) * resRight;

				vec3 tmp_gpu = determinantB * (finalM_gpu_a + finalM_gpu_b);

				//================================================================================


				float D = dot(tmp_gpu, tmp_gpu) + (3.0 * tmp_gpu.y * tmp_gpu.y - 2.0 * tmp_gpu.x * tmp_gpu.z);
	
				if (D < 0) D = 0;
				float sqrtD = sqrt(D);

				float L1 = ((tmp_gpu.x + tmp_gpu.z) + sqrtD) * 0.5;
				float L2 = ((tmp_gpu.x + tmp_gpu.z) - sqrtD) * 0.5;


				// float gauss = L1 * L2;
	
				// float mean = 0.5 * (L1 + L2);

				return vec2(L1, L2);
			}


            void main() {
                vec4 p = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy), 0);
                vec4 n = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy), 0);
                if(p == vec4(0.0))
                    discard;

                vec4 pTop = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,1)), 0);
                vec4 pRight = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(1,0)), 0);

                vec2 eigenvalues;
                if(pTop != vec4(0) && pRight!= vec4(0)){
                    vec4 nTop = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(0,1)), 0);
                    vec4 nRight = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(1,0)), 0);

                    eigenvalues = CalcCurvature_ShapeOperator(p.xyz, pRight.xyz, pTop.xyz, n.xyz, nRight.xyz, nTop.xyz);
                }
                else{
                    vec4 pBottom = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0);
                    vec4 pLeft = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0);
                    vec4 nBottom = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0);
                    vec4 nLeft = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0);

                    eigenvalues = CalcCurvature_ShapeOperator(p.xyz, pLeft.xyz, pBottom.xyz, n.xyz, nLeft.xyz, nBottom.xyz);

                }
                float mean_curv = 0.5 * (eigenvalues.x + eigenvalues.y);

                //TODO: If the effects of this discarding are really bothering, one could in an additional shader pass use the curvature of a neighbouring pixel for the nan and inf values.
                if(isnan(mean_curv) || isinf(mean_curv))
                    discard;
                fragCurvature = vec4(vec3(mean_curv),1.0);
            }
                
            -->
            </snippet>
        </shader>

        <shader name="prantl2mean">
          <snippet type="version">420</snippet>
          <snippet type="string">
            <!--
			#define TRIANGLE_VERTICES  3


            out vec4 fragCurvature;

            uniform sampler2D tex_fragPosition;
            uniform sampler2D tex_fragNormal;

//Begin
			vec2 CalcCurvature_ShapeOperator_2edge(vec3 a, vec3 b, vec3 c, vec3 an, vec3 bn, vec3 cn)
			{
	
				vec3 local_trianglePos[TRIANGLE_VERTICES];
				vec3 local_triangleNor[TRIANGLE_VERTICES];

	
				//=========================================================================================================

				vec3 _ba_ = (b - a);
				vec3 _ca_ = (c - a);

	
	
				vec3 axis[TRIANGLE_VERTICES];
				axis[0] = normalize(_ba_);
				axis[2] = normalize(cross(axis[0], _ca_));    
				axis[1] = normalize(cross(axis[0], axis[2]));




                mat3 transformMatrix = mat3(axis[0][0], axis[1][0], axis[2][0],
                                            axis[0][1], axis[1][1], axis[2][1],
                                            axis[0][2], axis[1][2], axis[2][2]);
				

				local_trianglePos[0] = vec3(0, 0, 0);
				local_triangleNor[0] = transformMatrix* an;
	
				local_trianglePos[1] = transformMatrix* _ba_;	
				local_triangleNor[1] = transformMatrix* bn;

				local_trianglePos[2] = transformMatrix* _ca_;	
				local_triangleNor[2] = transformMatrix* cn;
	
				vec2 u;
				vec2 v;

				vec2 du;
				vec2 dv;

				u.x = local_trianglePos[1].x - local_trianglePos[0].x;
				u.y = local_trianglePos[2].x - local_trianglePos[1].x;
	
				v.x = local_trianglePos[1].y - local_trianglePos[0].y;
				v.y = local_trianglePos[2].y - local_trianglePos[1].y;
		
				du.x = local_triangleNor[1].x - local_triangleNor[0].x;
				du.y = local_triangleNor[2].x - local_triangleNor[1].x;
	
				dv.x = local_triangleNor[1].y - local_triangleNor[0].y;
				dv.y = local_triangleNor[2].y - local_triangleNor[1].y;	
		
				//===============================================================================
				

				//inverse of 3x3 matrix
				//invB = inverse of B

				float aa = dot(u, u);
				float bb = dot(u, v);
				float cc = dot(v, v);

				float invB_B = -(bb * cc);
				float invB_C =  (bb * bb);
				float invB_D =  (aa * cc);
				float invB_E = -(aa * bb);
				float invB_A = -invB_C + (cc * cc) + invB_D;
				float invB_F =  (aa * aa) + invB_D - invB_C;

				float determinantB = 1.0 / ((aa + cc) * (invB_D - invB_C));



				//=======================================================================================

				mat4 tmp;
	
	
				tmp[0][0] = v.x * invB_B + u.x * invB_A;
				tmp[0][1] = v.x * invB_C + u.x * invB_B;
				tmp[0][2] = v.y * invB_B + u.y * invB_A;
				tmp[0][3] = v.y * invB_C + u.y * invB_B;


				tmp[1][0] = v.x * invB_D + u.x * invB_B;
				tmp[1][1] = v.x * invB_E + u.x * invB_D;
				tmp[1][2] = v.y * invB_D + u.y * invB_B;
				tmp[1][3] = v.y * invB_E + u.y * invB_D;


				tmp[2][0] = v.x * invB_E + u.x * invB_C;
				tmp[2][1] = v.x * invB_F + u.x * invB_E;
				tmp[2][2] = v.y * invB_E + u.y * invB_C;
				tmp[2][3] = v.y * invB_F + u.y * invB_E;


				tmp[3][0] = 0;
				tmp[3][1] = 0;
				tmp[3][2] = 0;
				tmp[3][3] = 0;

				//================================================================================

				vec4 tmp_gpu = determinantB * vec4(du.x, dv.x, du.y, dv.y) * tmp;
				
				//================================================================================


				float D = dot(tmp_gpu, tmp_gpu) + (3.0 * tmp_gpu.y * tmp_gpu.y - 2.0 * tmp_gpu.x * tmp_gpu.z);
	
				if (D < 0) D = 0;
				float sqrtD = sqrt(D);

				float L1 = ((tmp_gpu.x + tmp_gpu.z) + sqrtD) * 0.5;
				float L2 = ((tmp_gpu.x + tmp_gpu.z) - sqrtD) * 0.5;


				// float gauss = L1 * L2;
	
				// float mean = 0.5 * (L1 + L2);

				return vec2(L1, L2);
			}

            void main() {
                vec4 p = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy), 0);
                vec4 n = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy), 0);
                if(p == vec4(0.0))
                    discard;

                vec4 pTop = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,1)), 0);
                vec4 pRight = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(1,0)), 0);

                vec2 eigenvalues;
                if(pTop != vec4(0) && pRight!= vec4(0)){
                    vec4 nTop = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(0,1)), 0);
                    vec4 nRight = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(1,0)), 0);

                    eigenvalues = CalcCurvature_ShapeOperator_2edge(p.xyz, pRight.xyz, pTop.xyz, n.xyz, nRight.xyz, nTop.xyz);
                }
                else{
                    vec4 pBottom = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0);
                    vec4 pLeft = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0);
                    vec4 nBottom = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0);
                    vec4 nLeft = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0);

                    eigenvalues = CalcCurvature_ShapeOperator_2edge(p.xyz, pLeft.xyz, pBottom.xyz, n.xyz, nLeft.xyz, nBottom.xyz);

                }
                float mean_curv = 0.5 * (eigenvalues.x + eigenvalues.y);
                if(isnan(mean_curv) || isinf(mean_curv))
                    discard;

                fragCurvature = vec4(vec3(mean_curv),1.0);
            }
                
            -->
            </snippet>
        </shader>
        <shader name="prantlradial">
          <snippet type="version">420</snippet>
          <snippet type="string">
            <!--
			#define TRIANGLE_VERTICES  3


            out vec4 fragCurvature;

            uniform sampler2D tex_fragPosition;
            uniform sampler2D tex_fragNormal;

//Begin

			float CalcCurvature_ShapeOperator(vec3 a, vec3 b, vec3 c, vec3 an, vec3 bn, vec3 cn)
			{
	
				vec3 local_trianglePos[TRIANGLE_VERTICES];
				vec3 local_triangleNor[TRIANGLE_VERTICES];

	
				//=========================================================================================================

				vec3 _ba_ = (b - a);
				vec3 _ca_ = (c - a);

	
	
				vec3 axis[TRIANGLE_VERTICES];
				axis[0] = normalize(_ba_);
				axis[2] = normalize(cross(axis[0], _ca_));    
				axis[1] = normalize(cross(axis[0], axis[2]));
				
                mat3 transformMatrix = mat3(axis[0][0], axis[1][0], axis[2][0],
                                            axis[0][1], axis[1][1], axis[2][1],
                                            axis[0][2], axis[1][2], axis[2][2]);
				
				local_trianglePos[0] = vec3(0,0,0);
				local_triangleNor[0] = transformMatrix * an;
	
				local_trianglePos[1] = transformMatrix * _ba_;	
				local_triangleNor[1] = transformMatrix * bn;

				local_trianglePos[2] = transformMatrix * _ca_;	
				local_triangleNor[2] = transformMatrix * cn;
	
				vec3 u;
				vec3 v;

				vec3 du;
				vec3 dv;

				u.x = local_trianglePos[1].x - local_trianglePos[0].x;
				u.y = local_trianglePos[2].x - local_trianglePos[1].x;
				u.z = local_trianglePos[0].x - local_trianglePos[2].x;

				v.x = local_trianglePos[1].y - local_trianglePos[0].y;
				v.y = local_trianglePos[2].y - local_trianglePos[1].y;
				v.z = local_trianglePos[0].y - local_trianglePos[2].y;
	

				du.x = local_triangleNor[1].x - local_triangleNor[0].x;
				du.y = local_triangleNor[2].x - local_triangleNor[1].x;
				du.z = local_triangleNor[0].x - local_triangleNor[2].x;

				dv.x = local_triangleNor[1].y - local_triangleNor[0].y;
				dv.y = local_triangleNor[2].y - local_triangleNor[1].y;	
				dv.z = local_triangleNor[0].y - local_triangleNor[2].y;
	
				//===============================================================================


				
				//inverse of 3x3 matrix
				//invB = inverse of B

				float aa = dot(u, u);
				float bb = dot(u, v);
				float cc = dot(v, v);

				float invB_B = -(bb * cc);
				float invB_C =  (bb * bb);
				float invB_D =  (aa * cc);
				float invB_E = -(aa * bb);
				float invB_A = -invB_C + (cc * cc) + invB_D;
				float invB_F =  (aa * aa) + invB_D - invB_C;

				float determinantB = 1.0 / ((aa + cc) * (invB_D - invB_C));



				//=======================================================================================

				//col based matrices
				mat3 resLeft;
				mat3 resRight;
	
				resLeft[0][0] = v.x * invB_B + u.x * invB_A;
				resLeft[0][1] = v.x * invB_C + u.x * invB_B;
				resLeft[0][2] = v.y * invB_B + u.y * invB_A;
				resRight[0][0] = v.y * invB_C + u.y * invB_B;
				resRight[0][1] = v.z * invB_B + u.z * invB_A;
				resRight[0][2] = v.z * invB_C + u.z * invB_B;

				resLeft[1][0] = v.x * invB_D + u.x * invB_B;
				resLeft[1][1] = v.x * invB_E + u.x * invB_D;
				resLeft[1][2] = v.y * invB_D + u.y * invB_B;
				resRight[1][0] = v.y * invB_E + u.y * invB_D;
				resRight[1][1] = v.z * invB_D + u.z * invB_B;
				resRight[1][2] = v.z * invB_E + u.z * invB_D;

				resLeft[2][0] = v.x * invB_E + u.x * invB_C;
				resLeft[2][1] = v.x * invB_F + u.x * invB_E;
				resLeft[2][2] = v.y * invB_E + u.y * invB_C;
				resRight[2][0] = v.y * invB_F + u.y * invB_E;
				resRight[2][1] = v.z * invB_E + u.z * invB_C;
				resRight[2][2] = v.z * invB_F + u.z * invB_E;

				//================================================================================
				
				vec3 finalM_gpu_a = vec3(du.x, dv.x, du.y) * resLeft;
				vec3 finalM_gpu_b = vec3(dv.y, du.z, dv.z) * resRight;

				vec3 tmp_gpu = determinantB * (finalM_gpu_a + finalM_gpu_b);

				//================================================================================


				float D = dot(tmp_gpu, tmp_gpu) + (3.0 * tmp_gpu.y * tmp_gpu.y - 2.0 * tmp_gpu.x * tmp_gpu.z);
	
				if (D < 0) D = 0;
				float sqrtD = sqrt(D);

				float L1 = ((tmp_gpu.x + tmp_gpu.z) + sqrtD) * 0.5;
				float L2 = ((tmp_gpu.x + tmp_gpu.z) - sqrtD) * 0.5;

                //https://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html
                vec2 eigenvec1;

                if(tmp_gpu.y ==0 ){
                    eigenvec1.x = L1 - tmp_gpu.z;
                    eigenvec1.y = tmp_gpu.y;
                }
                else
                {
                    eigenvec1 = vec2(1.0, 0.0);
                }

                vec3 viewdir = normalize(vec3(0.0, 0.0, 0.0) - a); 
                viewdir = transformMatrix * viewdir; //transform viewdir into local coordinates //TODO: is this correct
                viewdir = normalize(viewdir);
                vec2 proj_viewdir = (viewdir - (dot(viewdir,local_triangleNor[0]) * local_triangleNor[0])).xy; //project onto tangent plane
                float cos = dot(normalize(proj_viewdir), normalize(eigenvec1));
                float radial_curv = L1 * cos * cos + L2 * (1- cos * cos);

				return radial_curv;
			}


            void main() {
                vec4 p = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy), 0);
                vec4 n = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy), 0);
                if(p == vec4(0.0))
                    discard;

                vec4 pTop = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,1)), 0);
                vec4 pRight = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(1,0)), 0);

                float curv;
                if(pTop != vec4(0) && pRight!= vec4(0)){
                    vec4 nTop = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(0,1)), 0);
                    vec4 nRight = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(1,0)), 0);

                    curv = CalcCurvature_ShapeOperator(p.xyz, pRight.xyz, pTop.xyz, n.xyz, nRight.xyz, nTop.xyz);
                }
                else{
                    vec4 pBottom = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0);
                    vec4 pLeft = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0);
                    vec4 nBottom = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0);
                    vec4 nLeft = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0);

                    curv = CalcCurvature_ShapeOperator(p.xyz, pLeft.xyz, pBottom.xyz, n.xyz, nLeft.xyz, nBottom.xyz);

                }

                if(isnan(curv) || isinf(curv))
                    discard;
                fragCurvature = vec4(vec3(curv),1.0);
            }
                
            -->
            </snippet>
        </shader>

        <shader name="prantl2radial">
          <snippet type="version">420</snippet>
          <snippet type="string">
            <!--
			#define TRIANGLE_VERTICES  3


            out vec4 fragCurvature;

            uniform sampler2D tex_fragPosition;
            uniform sampler2D tex_fragNormal;

//Begin
			float CalcCurvature_ShapeOperator_2edge(vec3 a, vec3 b, vec3 c, vec3 an, vec3 bn, vec3 cn)
			{
	
				vec3 local_trianglePos[TRIANGLE_VERTICES];
				vec3 local_triangleNor[TRIANGLE_VERTICES];

	
				//=========================================================================================================

				vec3 _ba_ = (b - a);
				vec3 _ca_ = (c - a);

	
	
				vec3 axis[TRIANGLE_VERTICES];
				axis[0] = normalize(_ba_);
				axis[2] = normalize(cross(axis[0], _ca_));    
				axis[1] = normalize(cross(axis[0], axis[2]));




                mat3 transformMatrix = mat3(axis[0][0], axis[1][0], axis[2][0],
                                            axis[0][1], axis[1][1], axis[2][1],
                                            axis[0][2], axis[1][2], axis[2][2]);
				

				local_trianglePos[0] = vec3(0, 0, 0);
				local_triangleNor[0] = transformMatrix* an;
	
				local_trianglePos[1] = transformMatrix* _ba_;	
				local_triangleNor[1] = transformMatrix* bn;

				local_trianglePos[2] = transformMatrix* _ca_;	
				local_triangleNor[2] = transformMatrix* cn;
	
				vec2 u;
				vec2 v;

				vec2 du;
				vec2 dv;

				u.x = local_trianglePos[1].x - local_trianglePos[0].x;
				u.y = local_trianglePos[2].x - local_trianglePos[1].x;
	
				v.x = local_trianglePos[1].y - local_trianglePos[0].y;
				v.y = local_trianglePos[2].y - local_trianglePos[1].y;
		
				du.x = local_triangleNor[1].x - local_triangleNor[0].x;
				du.y = local_triangleNor[2].x - local_triangleNor[1].x;
	
				dv.x = local_triangleNor[1].y - local_triangleNor[0].y;
				dv.y = local_triangleNor[2].y - local_triangleNor[1].y;	
		
				//===============================================================================
				

				//inverse of 3x3 matrix
				//invB = inverse of B

				float aa = dot(u, u);
				float bb = dot(u, v);
				float cc = dot(v, v);

				float invB_B = -(bb * cc);
				float invB_C =  (bb * bb);
				float invB_D =  (aa * cc);
				float invB_E = -(aa * bb);
				float invB_A = -invB_C + (cc * cc) + invB_D;
				float invB_F =  (aa * aa) + invB_D - invB_C;

				float determinantB = 1.0 / ((aa + cc) * (invB_D - invB_C));



				//=======================================================================================

				mat4 tmp;
	
	
				tmp[0][0] = v.x * invB_B + u.x * invB_A;
				tmp[0][1] = v.x * invB_C + u.x * invB_B;
				tmp[0][2] = v.y * invB_B + u.y * invB_A;
				tmp[0][3] = v.y * invB_C + u.y * invB_B;


				tmp[1][0] = v.x * invB_D + u.x * invB_B;
				tmp[1][1] = v.x * invB_E + u.x * invB_D;
				tmp[1][2] = v.y * invB_D + u.y * invB_B;
				tmp[1][3] = v.y * invB_E + u.y * invB_D;


				tmp[2][0] = v.x * invB_E + u.x * invB_C;
				tmp[2][1] = v.x * invB_F + u.x * invB_E;
				tmp[2][2] = v.y * invB_E + u.y * invB_C;
				tmp[2][3] = v.y * invB_F + u.y * invB_E;


				tmp[3][0] = 0;
				tmp[3][1] = 0;
				tmp[3][2] = 0;
				tmp[3][3] = 0;

				//================================================================================

				vec4 tmp_gpu = determinantB * vec4(du.x, dv.x, du.y, dv.y) * tmp;
				
				//================================================================================


				float D = dot(tmp_gpu, tmp_gpu) + (3.0 * tmp_gpu.y * tmp_gpu.y - 2.0 * tmp_gpu.x * tmp_gpu.z);
	
				if (D < 0) D = 0;
				float sqrtD = sqrt(D);

				float L1 = ((tmp_gpu.x + tmp_gpu.z) + sqrtD) * 0.5;
				float L2 = ((tmp_gpu.x + tmp_gpu.z) - sqrtD) * 0.5;
                //https://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html
                //https://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html
                vec2 eigenvec1;

                if(tmp_gpu.y ==0 ){
                    eigenvec1.x = L1 - tmp_gpu.z;
                    eigenvec1.y = tmp_gpu.y;
                }
                else
                {
                    eigenvec1 = vec2(1.0, 0.0);
                }

                vec3 viewdir = normalize(vec3(0.0, 0.0, 0.0) - a); 
                viewdir = normalize(transformMatrix * viewdir); //transform viewdir into local coordinates
                vec2 proj_viewdir = (viewdir - dot(viewdir,local_triangleNor[0])* local_triangleNor[0]).xy; //project onto tangent plane
                float cos = dot(normalize(proj_viewdir), normalize(eigenvec1));
                float radial_curv = L1 * cos * cos + L2 * (1- cos * cos);

				return radial_curv;
			}

            void main() {
                vec4 p = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy), 0);
                vec4 n = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy), 0);
                if(p == vec4(0.0))
                    discard;

                vec4 pTop = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,1)), 0);
                vec4 pRight = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(1,0)), 0);

                float radial_curv;
                if(pTop != vec4(0) && pRight!= vec4(0)){
                    vec4 nTop = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(0,1)), 0);
                    vec4 nRight = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(1,0)), 0);

                    radial_curv = CalcCurvature_ShapeOperator_2edge(p.xyz, pRight.xyz, pTop.xyz, n.xyz, nRight.xyz, nTop.xyz);
                }
                else{
                    vec4 pBottom = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0);
                    vec4 pLeft = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0);
                    vec4 nBottom = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0);
                    vec4 nLeft = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0);

                    radial_curv = CalcCurvature_ShapeOperator_2edge(p.xyz, pLeft.xyz, pBottom.xyz, n.xyz, nLeft.xyz, nBottom.xyz);

                }

                if(isnan(radial_curv) || isinf(radial_curv))
                    discard;
                
                fragCurvature = vec4(vec3(radial_curv),1.0);
            }
                
            -->
            </snippet>
        </shader>
        
        <shader name="prantlgaussian">
          <snippet type="version">420</snippet>
          <snippet type="string">
            <!--
			#define TRIANGLE_VERTICES  3


            out vec4 fragCurvature;

            uniform sampler2D tex_fragPosition;
            uniform sampler2D tex_fragNormal;

//Begin

			vec2 CalcCurvature_ShapeOperator(vec3 a, vec3 b, vec3 c, vec3 an, vec3 bn, vec3 cn)
			{
	
				vec3 local_trianglePos[TRIANGLE_VERTICES];
				vec3 local_triangleNor[TRIANGLE_VERTICES];

	
				//=========================================================================================================

				vec3 _ba_ = (b - a);
				vec3 _ca_ = (c - a);

	
	
				vec3 axis[TRIANGLE_VERTICES];
				axis[0] = normalize(_ba_);
				axis[2] = normalize(cross(axis[0], _ca_));    
				axis[1] = normalize(cross(axis[0], axis[2]));
				
				// mat3 transformMatrix = mat3(axis[0], axis[1], axis[2]);  
                // transformMatrix = transpose(transformMatrix);
                mat3 transformMatrix = mat3(axis[0][0], axis[1][0], axis[2][0],
                                            axis[0][1], axis[1][1], axis[2][1],
                                            axis[0][2], axis[1][2], axis[2][2]);
				
				local_trianglePos[0] = vec3(0,0,0);
				local_triangleNor[0] = transformMatrix * an;
	
				local_trianglePos[1] = transformMatrix * _ba_;	
				local_triangleNor[1] = transformMatrix * bn;

				local_trianglePos[2] = transformMatrix * _ca_;	
				local_triangleNor[2] = transformMatrix * cn;
	
				vec3 u;
				vec3 v;

				vec3 du;
				vec3 dv;

				u.x = local_trianglePos[1].x - local_trianglePos[0].x;
				u.y = local_trianglePos[2].x - local_trianglePos[1].x;
				u.z = local_trianglePos[0].x - local_trianglePos[2].x;

				v.x = local_trianglePos[1].y - local_trianglePos[0].y;
				v.y = local_trianglePos[2].y - local_trianglePos[1].y;
				v.z = local_trianglePos[0].y - local_trianglePos[2].y;
	

				du.x = local_triangleNor[1].x - local_triangleNor[0].x;
				du.y = local_triangleNor[2].x - local_triangleNor[1].x;
				du.z = local_triangleNor[0].x - local_triangleNor[2].x;

				dv.x = local_triangleNor[1].y - local_triangleNor[0].y;
				dv.y = local_triangleNor[2].y - local_triangleNor[1].y;	
				dv.z = local_triangleNor[0].y - local_triangleNor[2].y;
	
				//===============================================================================


				
				//inverse of 3x3 matrix
				//invB = inverse of B

				float aa = dot(u, u);
				float bb = dot(u, v);
				float cc = dot(v, v);

				float invB_B = -(bb * cc);
				float invB_C =  (bb * bb);
				float invB_D =  (aa * cc);
				float invB_E = -(aa * bb);
				float invB_A = -invB_C + (cc * cc) + invB_D;
				float invB_F =  (aa * aa) + invB_D - invB_C;

				float determinantB = 1.0 / ((aa + cc) * (invB_D - invB_C));



				//=======================================================================================

				//col based matrices
				mat3 resLeft;
				mat3 resRight;
	
				resLeft[0][0] = v.x * invB_B + u.x * invB_A;
				resLeft[0][1] = v.x * invB_C + u.x * invB_B;
				resLeft[0][2] = v.y * invB_B + u.y * invB_A;
				resRight[0][0] = v.y * invB_C + u.y * invB_B;
				resRight[0][1] = v.z * invB_B + u.z * invB_A;
				resRight[0][2] = v.z * invB_C + u.z * invB_B;

				resLeft[1][0] = v.x * invB_D + u.x * invB_B;
				resLeft[1][1] = v.x * invB_E + u.x * invB_D;
				resLeft[1][2] = v.y * invB_D + u.y * invB_B;
				resRight[1][0] = v.y * invB_E + u.y * invB_D;
				resRight[1][1] = v.z * invB_D + u.z * invB_B;
				resRight[1][2] = v.z * invB_E + u.z * invB_D;

				resLeft[2][0] = v.x * invB_E + u.x * invB_C;
				resLeft[2][1] = v.x * invB_F + u.x * invB_E;
				resLeft[2][2] = v.y * invB_E + u.y * invB_C;
				resRight[2][0] = v.y * invB_F + u.y * invB_E;
				resRight[2][1] = v.z * invB_E + u.z * invB_C;
				resRight[2][2] = v.z * invB_F + u.z * invB_E;

				//================================================================================
				
				vec3 finalM_gpu_a = vec3(du.x, dv.x, du.y) * resLeft;
				vec3 finalM_gpu_b = vec3(dv.y, du.z, dv.z) * resRight;

				vec3 tmp_gpu = determinantB * (finalM_gpu_a + finalM_gpu_b);

				//================================================================================


				float D = dot(tmp_gpu, tmp_gpu) + (3.0 * tmp_gpu.y * tmp_gpu.y - 2.0 * tmp_gpu.x * tmp_gpu.z);
	
				if (D < 0) D = 0;
				float sqrtD = sqrt(D);

				float L1 = ((tmp_gpu.x + tmp_gpu.z) + sqrtD) * 0.5;
				float L2 = ((tmp_gpu.x + tmp_gpu.z) - sqrtD) * 0.5;


				// float gauss = L1 * L2;
	
				// float mean = 0.5 * (L1 + L2);

				return vec2(L1, L2);
			}


            void main() {
                vec4 p = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy), 0);
                vec4 n = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy), 0);
                if(p == vec4(0.0))
                    discard;

                vec4 pTop = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,1)), 0);
                vec4 pRight = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(1,0)), 0);

                vec2 eigenvalues;
                if(pTop != vec4(0) && pRight!= vec4(0)){
                    vec4 nTop = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(0,1)), 0);
                    vec4 nRight = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(1,0)), 0);

                    eigenvalues = CalcCurvature_ShapeOperator(p.xyz, pRight.xyz, pTop.xyz, n.xyz, nRight.xyz, nTop.xyz);
                }
                else{
                    vec4 pBottom = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0);
                    vec4 pLeft = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0);
                    vec4 nBottom = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0);
                    vec4 nLeft = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0);

                    eigenvalues = CalcCurvature_ShapeOperator(p.xyz, pLeft.xyz, pBottom.xyz, n.xyz, nLeft.xyz, nBottom.xyz);

                }
                float gauss_curv = (eigenvalues.x * eigenvalues.y);

                if(isnan(gauss_curv) || isinf(gauss_curv))
                    discard;
                fragCurvature = vec4(vec3(gauss_curv),1.0);
            }
                
            -->
            </snippet>
        </shader>

        <shader name="prantl2gaussian">
          <snippet type="version">420</snippet>
          <snippet type="string">
            <!--
			#define TRIANGLE_VERTICES  3


            out vec4 fragCurvature;

            uniform sampler2D tex_fragPosition;
            uniform sampler2D tex_fragNormal;

//Begin
			vec2 CalcCurvature_ShapeOperator_2edge(vec3 a, vec3 b, vec3 c, vec3 an, vec3 bn, vec3 cn)
			{
	
				vec3 local_trianglePos[TRIANGLE_VERTICES];
				vec3 local_triangleNor[TRIANGLE_VERTICES];

	
				//=========================================================================================================

				vec3 _ba_ = (b - a);
				vec3 _ca_ = (c - a);

	
	
				vec3 axis[TRIANGLE_VERTICES];
				axis[0] = normalize(_ba_);
				axis[2] = normalize(cross(axis[0], _ca_));    
				axis[1] = normalize(cross(axis[0], axis[2]));




                mat3 transformMatrix = mat3(axis[0][0], axis[1][0], axis[2][0],
                                            axis[0][1], axis[1][1], axis[2][1],
                                            axis[0][2], axis[1][2], axis[2][2]);
				

				local_trianglePos[0] = vec3(0, 0, 0);
				local_triangleNor[0] = transformMatrix* an;
	
				local_trianglePos[1] = transformMatrix* _ba_;	
				local_triangleNor[1] = transformMatrix* bn;

				local_trianglePos[2] = transformMatrix* _ca_;	
				local_triangleNor[2] = transformMatrix* cn;
	
				vec2 u;
				vec2 v;

				vec2 du;
				vec2 dv;

				u.x = local_trianglePos[1].x - local_trianglePos[0].x;
				u.y = local_trianglePos[2].x - local_trianglePos[1].x;
	
				v.x = local_trianglePos[1].y - local_trianglePos[0].y;
				v.y = local_trianglePos[2].y - local_trianglePos[1].y;
		
				du.x = local_triangleNor[1].x - local_triangleNor[0].x;
				du.y = local_triangleNor[2].x - local_triangleNor[1].x;
	
				dv.x = local_triangleNor[1].y - local_triangleNor[0].y;
				dv.y = local_triangleNor[2].y - local_triangleNor[1].y;	
		
				//===============================================================================
				

				//inverse of 3x3 matrix
				//invB = inverse of B

				float aa = dot(u, u);
				float bb = dot(u, v);
				float cc = dot(v, v);

				float invB_B = -(bb * cc);
				float invB_C =  (bb * bb);
				float invB_D =  (aa * cc);
				float invB_E = -(aa * bb);
				float invB_A = -invB_C + (cc * cc) + invB_D;
				float invB_F =  (aa * aa) + invB_D - invB_C;

				float determinantB = 1.0 / ((aa + cc) * (invB_D - invB_C));



				//=======================================================================================

				mat4 tmp;
	
	
				tmp[0][0] = v.x * invB_B + u.x * invB_A;
				tmp[0][1] = v.x * invB_C + u.x * invB_B;
				tmp[0][2] = v.y * invB_B + u.y * invB_A;
				tmp[0][3] = v.y * invB_C + u.y * invB_B;


				tmp[1][0] = v.x * invB_D + u.x * invB_B;
				tmp[1][1] = v.x * invB_E + u.x * invB_D;
				tmp[1][2] = v.y * invB_D + u.y * invB_B;
				tmp[1][3] = v.y * invB_E + u.y * invB_D;


				tmp[2][0] = v.x * invB_E + u.x * invB_C;
				tmp[2][1] = v.x * invB_F + u.x * invB_E;
				tmp[2][2] = v.y * invB_E + u.y * invB_C;
				tmp[2][3] = v.y * invB_F + u.y * invB_E;


				tmp[3][0] = 0;
				tmp[3][1] = 0;
				tmp[3][2] = 0;
				tmp[3][3] = 0;

				//================================================================================

				vec4 tmp_gpu = determinantB * vec4(du.x, dv.x, du.y, dv.y) * tmp;
				
				//================================================================================


				float D = dot(tmp_gpu, tmp_gpu) + (3.0 * tmp_gpu.y * tmp_gpu.y - 2.0 * tmp_gpu.x * tmp_gpu.z);
	
				if (D < 0) D = 0;
				float sqrtD = sqrt(D);

				float L1 = ((tmp_gpu.x + tmp_gpu.z) + sqrtD) * 0.5;
				float L2 = ((tmp_gpu.x + tmp_gpu.z) - sqrtD) * 0.5;


				// float gauss = L1 * L2;
	
				// float mean = 0.5 * (L1 + L2);

				return vec2(L1, L2);
			}
            //TODO: Fix all the prantl curvature (nan und inf)

            void main() {
                vec4 p = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy), 0);
                vec4 n = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy), 0);
                if(p == vec4(0.0))
                    discard;

                vec4 pTop = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,1)), 0);
                vec4 pRight = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(1,0)), 0);

                vec2 eigenvalues;
                if(pTop != vec4(0) && pRight!= vec4(0)){
                    vec4 nTop = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(0,1)), 0);
                    vec4 nRight = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(1,0)), 0);

                    eigenvalues = CalcCurvature_ShapeOperator_2edge(p.xyz, pRight.xyz, pTop.xyz, n.xyz, nRight.xyz, nTop.xyz);
                }
                else{
                    vec4 pBottom = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0);
                    vec4 pLeft = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0);
                    vec4 nBottom = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0);
                    vec4 nLeft = texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0);

                    eigenvalues = CalcCurvature_ShapeOperator_2edge(p.xyz, pLeft.xyz, pBottom.xyz, n.xyz, nLeft.xyz, nBottom.xyz);

                }
                float gauss_curv = (eigenvalues.x * eigenvalues.y);

                if(isnan(gauss_curv) || isinf(gauss_curv))
                    discard;
                fragCurvature = vec4(vec3(gauss_curv),1.0);
            }
                
            -->
            </snippet>
        </shader>
        <shader name="shadingGradient">
          <snippet type="version">330</snippet>
          <snippet type="string">
            <!--
            out vec4 fragCurvature;

            uniform sampler2D tex_fragPosition;
            uniform sampler2D tex_fragNormal;

            void main() {
                vec3 pixelPosition = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy), 0).xyz;
                vec3 pixelNormal = normalize(texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy), 0).xyz);

                float shading = dot(pixelNormal, normalize(-pixelPosition));

                float dx = dFdx(shading);
                float dy = dFdy(shading);

                fragCurvature = vec4(vec3(sqrt(dx*dx + dy*dy)/sqrt(2)), 1.0); 
            }
          -->
        </snippet>
      </shader>
        <shader name="shadingGradient4N">
          <snippet type="version">330</snippet>
          <snippet type="string">
            <!--
            out vec4 fragCurvature;

            uniform sampler2D tex_fragPosition;
            uniform sampler2D tex_fragNormal;

            void main() {
                vec3 pLeft = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy) - ivec2(1,0), 0).xyz;
                vec3 pRight = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy) + ivec2(1,0), 0).xyz;
                vec3 pTop = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy) + ivec2(0,1), 0).xyz;
                vec3 pBottom = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy) - ivec2(0,1), 0).xyz;

                vec3 nLeft = normalize(texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy) - ivec2(1,0), 0).xyz);
                vec3 nRight = normalize(texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy) + ivec2(1,0), 0).xyz);
                vec3 nTop = normalize(texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy) + ivec2(0,1), 0).xyz);
                vec3 nBottom = normalize(texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy) - ivec2(0,1), 0).xyz);

                float shadingLeft = dot(nLeft, normalize(-pLeft));
                float shadingRight = dot(nRight, normalize(-pRight));
                float shadingTop = dot(nTop, normalize(-pTop));
                float shadingBottom = dot(nBottom, normalize(-pBottom));

                float dx = 0.5 * (shadingRight - shadingLeft);
                float dy = 0.5 * (shadingTop - shadingBottom);

                fragCurvature = vec4(vec3(sqrt(dx*dx + dy*dy)/sqrt(2)), 1.0); 
            }
          -->
        </snippet>
      </shader>
        <shader name="normalDerivative">
          <snippet type="version">330</snippet>
          <snippet type="string">
            <!--
            out vec4 fragCurvature;

            uniform sampler2D tex_fragNormal;

            void main() {
                vec3 pixelNormal = normalize(texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy), 0).xyz);

                float dx = length(dFdx(pixelNormal));
                float dy = length(dFdy(pixelNormal));

                fragCurvature = vec4(vec3(sqrt(dx*dx + dy*dy)), 1.0); 
            }
          -->
        </snippet>
      </shader>
        
        <shader name="fragment">
          <snippet type="version">330</snippet>
          <snippet type="string">
            <!--
            out vec4 fragCurvature;

            uniform sampler2D tex_fragPosition;
            uniform sampler2D tex_fragCurvature;
            uniform sampler2D tex_fragNormal;

            vec4 showZerocrossing(float curvature, float curvatureDxy) {
                if(abs(curvature) <= 0.01 * curvatureDxy) {
                    return vec4(0);
                }
                return vec4(1);
            }

            void main() {
                vec3 pixelPosition = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy), 0).xyz;
                vec3 pixelNormal = normalize(texelFetch(tex_fragNormal, ivec2(gl_FragCoord.xy), 0).xyz);
                vec4 curvature = texelFetch(tex_fragCurvature, ivec2(gl_FragCoord.xy), 0);

                // if (curvature.xyz == vec3(1, 0, 0)) { // "Maske"
                //     fragCurvature=vec4(1);
                // }

                float f = 1.0;//0.01;
                float scaledCurvature = curvature.x * f;

                // TODO: use pixel 3D locations to calculate the derivative. Also smooth the result -> pull-push
                vec3 pixelPositionLeft = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0).xyz;
                vec3 pixelPositionTop = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,1)), 0).xyz;
                vec3 pixelPositionRight = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).xyz;
                vec3 pixelPositionBottom = texelFetch(tex_fragPosition, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).xyz;

                float curvatureDx = dFdx(scaledCurvature); // / length(pixelPositionLeft - pixelPositionRight);
                float curvatureDy = dFdy(scaledCurvature); // / length(pixelPositionTop - pixelPositionBottom);
                vec2 curvatureDirection = (vec2(curvatureDx, curvatureDy));

                // create local coordinate system at the pixel position
                vec3 h = normalize(vec3(-1));
                vec3 U = cross(pixelNormal, h);
                vec3 V = cross(h, U);

                // project the view vector into the local system
                vec3 v = normalize(-pixelPosition);
                vec2 vProjected = vec2(dot(U,v), dot (V,v));

                float isSuggestiveContour = sign(dot(vProjected, curvatureDirection));

                if (scaledCurvature >= 0) {
                    fragCurvature = vec4(1) - vec4(scaledCurvature, 0, 0, 0);
                } else {
                    fragCurvature = vec4(1) - vec4(0, -scaledCurvature, 0, 0);
                }

                if(isSuggestiveContour > 0) {
                    fragCurvature *= showZerocrossing(scaledCurvature, length(curvatureDirection));
                }

            }
          -->
        </snippet>
      </shader>
        
      </namespace>
        <namespace name="postprocessing">
        <shader name="blur">
          <snippet type="version">330</snippet>
          <snippet type="string">
            <!--

        out vec4 FragColor;
        uniform sampler2D screenTexture;

        uniform bool horizontal;
        uniform float weight[5] = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);

        void main()
        {             
        vec4 resultv4 = texelFetch(screenTexture, ivec2(gl_FragCoord.xy), 0) * weight[0]; // current fragment's contribution
        if(resultv4 == vec4(0))
            discard;
        vec3 result = resultv4.rgb;
        if(horizontal)
        {
            for(int i = 1; i < 5; ++i)
            {
                result += texelFetch(screenTexture, ivec2(gl_FragCoord.xy + vec2(i,0)), 0).rgb * weight[i]; // current fragment's contribution
                result += texelFetch(screenTexture, ivec2(gl_FragCoord.xy + vec2(-i,0)), 0).rgb * weight[i]; // current fragment's contribution
            }
        }
        else
        {
            for(int i = 1; i < 5; ++i)
            {
                result += texelFetch(screenTexture, ivec2(gl_FragCoord.xy + vec2(0,i)), 0).rgb * weight[i]; // current fragment's contribution
                result += texelFetch(screenTexture, ivec2(gl_FragCoord.xy + vec2(0,-i)), 0).rgb * weight[i]; // current fragment's contribution
            }
        }
        FragColor = vec4(result, 1.0);
        }
            -->
            </snippet>
        </shader>
        <shader name="perona-malik-blur">
          <snippet type="version">420</snippet>
          <snippet type="string">
            <!--
                out vec4 FragColor;
                uniform sampler2D screenTexture;
                uniform float lambda = 0.25;
                uniform float K = 1.0;

                void main()
                {             
                vec4 centre4 = texelFetch(screenTexture, ivec2(gl_FragCoord.xy), 0); // current fragment's contribution
                if(centre4 == vec4(0))
                    discard;
                vec3 centre = centre4.rgb;
                vec3 right = texelFetch(screenTexture, ivec2(gl_FragCoord.xy + vec2(1,0)), 0).rgb; // current fragment's contribution
                vec3 left = texelFetch(screenTexture, ivec2(gl_FragCoord.xy + vec2(-1,0)), 0).rgb; // current fragment's contribution
                vec3 up = texelFetch(screenTexture, ivec2(gl_FragCoord.xy + vec2(0,1)), 0).rgb; // current fragment's contribution
                vec3 down = texelFetch(screenTexture, ivec2(gl_FragCoord.xy + vec2(0,-1)), 0).rgb; // current fragment's contribution

                // Calculate differences
                vec3 dr = right - centre;
                vec3 dl = left - centre;
                vec3 du = up - centre;
                vec3 dd = down - centre;

                //Calculate g
                float gr = exp(-(length(dr)/K)*(length(dr)/K));
                float gl = exp(-(length(dl)/K)*(length(dl)/K));
                float gu = exp(-(length(du)/K)*(length(du)/K));
                float gd = exp(-(length(dd)/K)*(length(dd)/K));


                vec3 result = centre + lambda * (gr * dr + gl * dl + gu * du + gd * dd);
                FragColor = vec4(result, 1.0);
                }
            -->
            </snippet>
        </shader>
        <shader name="depthBlur">
          <snippet type="version">420</snippet>
          <snippet type="string">
            <!--
                out vec4 FragColor;
                uniform sampler2D screenTexture;
                uniform sampler2D positionTexture;
                uniform float depthdiff;
                void main()
                {
                    vec2 offsets[8] = vec2[](vec2(-1,1), vec2(0,1), vec2(1,1), 
                                             vec2(-1,0),            vec2(1, 0),
                                             vec2(-1, -1), vec2(0, -1), vec2(1, -1));
                    float weights[8] = float[](1, 2, 1,
                                               2,    2,
                                                1, 2, 1);
                    vec4 col = texelFetch(screenTexture, ivec2(gl_FragCoord.xy), 0);
                    vec4 pos = texelFetch(positionTexture, ivec2(gl_FragCoord.xy), 0);
                    if(col.a == 0 || pos.a == 0)
                        discard;
                    vec3 result = 4 * col.xyz;
                    float final_weight = 4;
                    for(int i = 0; i < 8; ++i){
                        vec4 colb = texelFetch(screenTexture, ivec2(gl_FragCoord.xy + offsets[i]), 0);
                        vec4 posb = texelFetch(positionTexture, ivec2(gl_FragCoord.xy + offsets[i]), 0);
                        if(posb.a != 0 && colb.a != 0 && abs(pos.z - posb.z) < depthdiff){
                            result += weights[i] * colb.xyz;
                            final_weight += weights[i];
                        }
                    }
                    FragColor = vec4(result / final_weight, 1.0);
                }
            -->
            </snippet>
        </shader>
        <shader name="gauss-depth-blur">
          <snippet type="version">330</snippet>
          <snippet type="string">
            <!--

        out vec4 FragColor;
        uniform sampler2D screenTexture;
        uniform sampler2D positionTexture;
         uniform float depthdiff;

        uniform bool horizontal;
        uniform float weight[5] = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);

        void main()
        {             
        vec4 resultv4 = texelFetch(screenTexture, ivec2(gl_FragCoord.xy), 0) * weight[0]; // current fragment's contribution
        if(resultv4 == vec4(0))
            discard;
        vec3 result = resultv4.rgb;
        vec3 pos = texelFetch(positionTexture, ivec2(gl_FragCoord.xy), 0).xyz;
        float final_weight = weight[0];
        if(horizontal)
        {
            for(int i = 1; i < 5; ++i)
            {
                vec3 cola = texelFetch(screenTexture, ivec2(gl_FragCoord.xy + vec2(i,0)), 0).rgb * weight[i]; // current fragment's contribution
                vec3 posa = texelFetch(positionTexture, ivec2(gl_FragCoord.xy + vec2(i,0)), 0).rgb; // current fragment's contribution
                if(abs(pos.z - posa.z) < depthdiff){
                    result += cola;
                    final_weight += weight[i];
                }
                else{
                    break;
                }
            }
            for(int i = 1; i < 5; ++i)
            {
                vec3 colb = texelFetch(screenTexture, ivec2(gl_FragCoord.xy + vec2(-i,0)), 0).rgb * weight[i]; // current fragment's contribution
                vec3 posb = texelFetch(positionTexture, ivec2(gl_FragCoord.xy + vec2(-i,0)), 0).rgb; // current fragment's contribution
                if(abs(pos.z - posb.z) < depthdiff){
                    result += colb;
                    final_weight += weight[i];
                }
                else{
                    break;
                }
            }
        }
        else
        {
            for(int i = 1; i < 5; ++i)
            {
                vec3 cola = texelFetch(screenTexture, ivec2(gl_FragCoord.xy + vec2(0,i)), 0).rgb * weight[i]; // current fragment's contribution
                vec3 posa = texelFetch(positionTexture, ivec2(gl_FragCoord.xy + vec2(0,i)), 0).rgb * weight[i]; // current fragment's contribution
                if(abs(pos.z - posa.z) < depthdiff){
                    result += cola;
                    final_weight += weight[i];
                }
                else{
                    break;
                }
            }
            for(int i = 1; i < 5; ++i)
            {
                vec3 colb = texelFetch(screenTexture, ivec2(gl_FragCoord.xy + vec2(0,-i)), 0).rgb * weight[i]; // current fragment's contribution
                vec3 posb = texelFetch(positionTexture, ivec2(gl_FragCoord.xy + vec2(0,-i)), 0).rgb * weight[i]; // current fragment's contribution
                if(abs(pos.z - posb.z) < depthdiff){
                    result += colb;
                    final_weight += weight[i];
                }
                else{
                    break;
                }
            }
        }
        FragColor = vec4(result / final_weight, 1.0);
        }
            -->
            </snippet>
        </shader>
      </namespace>
</btf>