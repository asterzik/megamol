<?xml version="1.0" encoding="utf-8"?>
<btf type="MegaMolGLSLShader" version="1.0" namespace="testCase_perspective">
    <include file="protein"/>
      <shader name="vertex">
        <snippet type="version">430</snippet>
        <snippet type="string">
        <!--
            in layout(location = 0) vec3 in_Position;	

            out VS_OUT
            {
                vec3 position;
            } vs_out;

            // uniform mat4 mvp; //projection * view * model matrix
            uniform mat4 model;
            uniform mat4 view;
            uniform mat4 proj;
            uniform float radius;

            void main()
            {
                // Pass Through
                vs_out.position = in_Position;
                
                // Calculation
                gl_Position = proj * view * model * vec4(in_Position , 1);//mvp * vec4(in_Position , 1);
            }

            -->
            </snippet>
        </shader>
      <shader name="fragment">
        <snippet type="version">430</snippet>
        <snippet type="string">
        <!--
            in VS_OUT
            {
                vec3 position;

            } fs_in;

            // uniform mat4 mv; //view * model matrix
            // uniform mat4 projection;


            layout(location=0) out vec4 FragNormal;
            layout(location=1) out vec4 FragPosition;

            uniform mat4 model;
            uniform mat4 view;
            uniform mat4 proj;
            uniform float radius;

            void main (void)
            {
                // Will be 1 at Sphere Border 
                // Will be 0 at Sphere Center
                float mag = dot(fs_in.position.xy, fs_in.position.xy);
                
                if(mag > 1.0)
                {
                    discard;
                }
                
                //Compare with https://stackoverflow.com/questions/10488086/drawing-a-sphere-in-opengl-es/10506172#10506172
                
                //Calculate depth of fragment
                float localDepth = sqrt(1.0 - mag);
                // float totalDepth = fs_in.position.z - localDepth * radiusSphere;


                //Calculate Normal
                vec3 normal = normalize(vec3(fs_in.position.xy, localDepth));
            
                // vec3 FragPos = (view * vec4(fs_in.position, 1.0)).xyz;
                // vec3 viewDir = normalize(viewpos.xyz - FragPos);
                vec3 FragPos = vec3(fs_in.position.xy, fs_in.position.z + localDepth * radius);
                
                normal = normalize(mat3(transpose(inverse(view * model))) * normal);
                //Calculate gl_FragDepth
                float far=gl_DepthRange.far; 
                float near=gl_DepthRange.near;
                vec4 clipFragPos = proj * vec4(FragPos, 1.0);
                // vec4 clipFragPos =  vec4(FragPos, 1.0);
                float ndcDepth = clipFragPos.z / clipFragPos.w;
                gl_FragDepth = (((far-near) * ndcDepth) + near + far) / 2.0;

                FragNormal = vec4(normal, 1.0);
                FragPosition = view * model * vec4(FragPos, 1.0);
            }

            -->
            </snippet>
        </shader>

</btf>