<?xml version="1.0" encoding="utf-8"?>
<btf type="MegaMolGLSLShader" version="1.0" namespace="pullpush">
    <include file="protein"/>

        <shader name="pullNormal">
            <snippet type="version">430</snippet>
            <snippet name="::protein::commondefines"/>
            <snippet type="string">
<!--
out vec4 fragNormal;

uniform float lf;
uniform int level;
uniform int level_max;
uniform float weightFactor;

uniform sampler2D inputTex_fragNormal;
uniform sampler2D inputTex_fragPosition;
uniform sampler2D pyramid_fragNormal;
uniform sampler2D maxDepth_texture;


void pull(out vec4 pulledFragNormal)
{
    // read all finer pixels' values
    vec4 fn_bl = (texelFetch(pyramid_fragNormal, ivec2(gl_FragCoord.xy) * 2 + ivec2(0), level-1));
    vec4 fn_tl = (texelFetch(pyramid_fragNormal, ivec2(gl_FragCoord.xy) * 2 + ivec2(0, 1), level-1));
    vec4 fn_tr = (texelFetch(pyramid_fragNormal, ivec2(gl_FragCoord.xy) * 2 + ivec2(1), level-1));
    vec4 fn_br = (texelFetch(pyramid_fragNormal, ivec2(gl_FragCoord.xy) * 2 + ivec2(1, 0), level-1));

    vec4 distanceWeights = vec4(1);
    float distanceWeightsSum = 4.0;

    pulledFragNormal.xyz =
    fn_bl.xyz * fn_bl.w * distanceWeights.x
    + fn_tl.xyz * fn_tl.w * distanceWeights.y
    + fn_tr.xyz * fn_tr.w * distanceWeights.z
    + fn_br.xyz * fn_br.w * distanceWeights.w;

    pulledFragNormal.w =
    fn_bl.w * distanceWeights.x
    + fn_tl.w * distanceWeights.y
    + fn_tr.w * distanceWeights.z
    + fn_br.w * distanceWeights.w;

    if (any(isnan(pulledFragNormal.xyz)) || any(isinf(pulledFragNormal.xyz))) {
        pulledFragNormal = vec4(0);
        return;
    }

    if (pulledFragNormal.xyz != vec3(0)) {
        pulledFragNormal.xyz = normalize(pulledFragNormal.xyz);
        pulledFragNormal.w = min(1, pulledFragNormal.w);
    } else {
        pulledFragNormal.w = 0;
    }
}

void main() {
    fragNormal = vec4(0);

    if (level == 0) {
        fragNormal = texelFetch(inputTex_fragNormal, ivec2(gl_FragCoord.xy), 0);
        float fragZ = abs(texelFetch(inputTex_fragPosition, ivec2(gl_FragCoord.xy), 0).z);

        float distanceWeight = fragZ*fragZ;

        float maxDepth = texelFetch(maxDepth_texture, ivec2(0,0), level_max - 1).x;
        if (fragNormal.xyz != vec3(0)) {
            fragNormal.w = weightFactor * distanceWeight / (maxDepth * maxDepth); // weight for this pixel
        }
         else {
            fragNormal.w = 0;// no weight for this void pixel
        }
        return;

    }

    pull(fragNormal);
}
-->
            </snippet>
        </shader>

        <shader name="pullCurvature">
            <snippet type="version">430</snippet>
            <snippet name="::protein::commondefines"/>
            <snippet type="string">
<!--

out vec4 fragCurvature;

uniform float lf;
uniform int level;

uniform sampler2D inputTex_fragCurvature;
uniform sampler2D inputTex_fragBarycenter;
uniform sampler2D inputTex_fragPosition;
uniform sampler2D pyramid_fragCurvature;

void pull(out vec4 pulledfragCurvature)
{
    // read all finer pixels' values
    vec4 fn_bl = (texelFetch(pyramid_fragCurvature, ivec2(gl_FragCoord.xy) * 2 + ivec2(0), level-1));
    vec4 fn_tl = (texelFetch(pyramid_fragCurvature, ivec2(gl_FragCoord.xy) * 2 + ivec2(0, 1), level-1));
    vec4 fn_tr = (texelFetch(pyramid_fragCurvature, ivec2(gl_FragCoord.xy) * 2 + ivec2(1), level-1));
    vec4 fn_br = (texelFetch(pyramid_fragCurvature, ivec2(gl_FragCoord.xy) * 2 + ivec2(1, 0), level-1));

    pulledfragCurvature.xyz = fn_bl.xyz * fn_bl.w + fn_tl.xyz * fn_tl.w + fn_tr.xyz * fn_tr.w + fn_br.xyz * fn_br.w;
    pulledfragCurvature.w = fn_bl.w + fn_tl.w + fn_tr.w + fn_br.w;

    if (isnan(pulledfragCurvature.y) || isinf(pulledfragCurvature.y) ) {
        pulledfragCurvature = vec4(0);
        return;
    }

    if ( pulledfragCurvature.y != 0) {
        pulledfragCurvature.y /= pulledfragCurvature.w;
        pulledfragCurvature.w = min(1, pulledfragCurvature.w);
    } else {
        pulledfragCurvature.w = 0;
    }
}

void main() {
    fragCurvature = vec4(0);

    if (level == 0) {
        fragCurvature = texelFetch(inputTex_fragCurvature, ivec2(gl_FragCoord.xy), 0);
        float fragBarycenter = texelFetch(inputTex_fragBarycenter, ivec2(gl_FragCoord.xy), 0).x;
        float fragZ = abs(texelFetch(inputTex_fragPosition, ivec2(gl_FragCoord.xy), 0).z);

        float distanceWeight = fragZ*fragZ;

        if ( fragCurvature.y != 0) { // auf y schauen, da aktuell noch keine Maske verwendet wird
            fragCurvature.w = 0.001 * distanceWeight;// * distanceWeight; // weight for this pixel
        } else {
            fragCurvature.w = 0; // no weight for this void pixel
        }
        return;
    }

    pull(fragCurvature);
}

-->
            </snippet>
        </shader>

        <shader name="pushNormal">
            <snippet type="version">430</snippet>
            <snippet name="::protein::commondefines"/>
            <snippet type="string">
<!--
out vec4 fragNormal;

uniform sampler2D pyramid_fragNormal;

uniform float lf;
uniform int level;
uniform int level_max;
uniform float gamma;

void addTexel(ivec2 offset, inout vec4 pushedFragNormal, inout float factor_sum, float factor)
{
    ivec2 c = offset + ivec2(gl_FragCoord.xy / 2);
    int max_coord = int(0.5/lf - 1);
    if (c.x < 0 || c.y < 0 || c.x > max_coord || c.y > max_coord)
    return;

    vec4 n = (texelFetch(pyramid_fragNormal, c, level + 1));

    if (any(isnan(n)) || any(isinf(n))) {
        return;
    }

    if( n.xyz != vec3(0)) {
        pushedFragNormal.xyz += normalize(n.xyz) * factor * n.w ;
        pushedFragNormal.w += n.w * factor * n.w ;
        factor_sum += factor * n.w ;
    }
}

void push(out vec4 pushedFragNormal)
{
    pushedFragNormal = vec4(0);
    float f_sum = 0;

    vec4 originalFragNormal = texelFetch(pyramid_fragNormal, ivec2(gl_FragCoord.xy), level);

    if (originalFragNormal.w == 1.0){
        pushedFragNormal = originalFragNormal;
        return;
    }
    // Let background stay background
    if(originalFragNormal == vec4(0.0f)){
        pushedFragNormal = originalFragNormal;
        return;
    }

    addTexel(ivec2(0, 0),  pushedFragNormal, f_sum, 9);
    if (int(gl_FragCoord.x) % 2 == 0) {
        if (int(gl_FragCoord.y) % 2 == 0) {
            addTexel(ivec2(-1, 0), pushedFragNormal, f_sum, 3);
            addTexel(ivec2(0, -1), pushedFragNormal, f_sum, 3);
            addTexel(ivec2(-1, -1), pushedFragNormal, f_sum, 1);
        } else {
            addTexel(ivec2(-1, 0), pushedFragNormal, f_sum, 3);
            addTexel(ivec2(0, +1), pushedFragNormal, f_sum, 3);
            addTexel(ivec2(-1, +1), pushedFragNormal, f_sum, 1);
        }
    } else {
        if (int(gl_FragCoord.y) % 2 == 0) {
            addTexel(ivec2(+1, 0), pushedFragNormal, f_sum, 3);
            addTexel(ivec2(0, -1), pushedFragNormal, f_sum, 3);
            addTexel(ivec2(+1, -1), pushedFragNormal, f_sum, 1);
        } else {
            addTexel(ivec2(+1, 0), pushedFragNormal, f_sum, 3);
            addTexel(ivec2(0, +1), pushedFragNormal, f_sum, 3);
            addTexel(ivec2(+1, +1), pushedFragNormal, f_sum, 1);
        }
    }

    if (any(isnan(pushedFragNormal.xyz)) || any(isinf(pushedFragNormal.xyz)) ) {
        return;
    }

    if (pushedFragNormal.xyz != vec3(0) && f_sum > 0) {
        pushedFragNormal.xyz = normalize(pushedFragNormal.xyz);
        pushedFragNormal.w /= f_sum;
    } else {
        pushedFragNormal.w = 0;
    }
 
    // Interpolation between original and pushed
    float alpha = originalFragNormal.w;
    //These max operations are necessary, because otherwise it could (and does) come to undefined behaviour
    alpha = 1.0 - pow(max(0.0, 1.0 - alpha),  max(1.0, gamma)); 
    pushedFragNormal.w = min(1, pushedFragNormal.w * (1 - alpha) + alpha);
    pushedFragNormal.xyz = originalFragNormal.xyz * alpha + pushedFragNormal.xyz * (1 - alpha);
    pushedFragNormal.xyz = normalize(pushedFragNormal.xyz);
}

void main() {
    fragNormal = vec4(0);
    push(fragNormal);
}
-->
            </snippet>
        </shader>

        <shader name="pushCurvature">
            <snippet type="version">430</snippet>
            <snippet name="::protein::commondefines"/>
            <snippet type="string">
<!--

out vec4 fragCurvature;

uniform sampler2D pyramid_fragCurvature;

uniform float lf;
uniform int level;
uniform int level_max;

void addTexel(ivec2 offset, inout vec4 pushedfragCurvature, inout float factor_sum, float factor)
{
    ivec2 c = offset + ivec2(gl_FragCoord.xy / 2);
    int max_coord = int(0.5/lf - 1);
    if (c.x < 0 || c.y < 0 || c.x > max_coord || c.y > max_coord)
    return;

    vec4 n = (texelFetch(pyramid_fragCurvature, c, level + 1));

    if (any(isnan(n)) || any(isinf(n))) {
        return;
    }

    if( n.y != 0) {
        pushedfragCurvature.y += n.y * factor * n.w;
        pushedfragCurvature.w += n.w * factor * n.w;
        factor_sum += factor * n.w;
    }
}

void push(out vec4 pushedfragCurvature)
{
    pushedfragCurvature = vec4(0);
    float f_sum = 0;

    vec4 originalfragCurvature = texelFetch(pyramid_fragCurvature, ivec2(gl_FragCoord.xy), level);

    if (originalfragCurvature.w == 1.0){
        pushedfragCurvature = originalfragCurvature;
        return;
    }

    addTexel(ivec2(0, 0),  pushedfragCurvature, f_sum, 9);
    if (int(gl_FragCoord.x) % 2 == 0) {
        if (int(gl_FragCoord.y) % 2 == 0) {
            addTexel(ivec2(-1, 0), pushedfragCurvature, f_sum, 3);
            addTexel(ivec2(0, -1), pushedfragCurvature, f_sum, 3);
            addTexel(ivec2(-1, -1), pushedfragCurvature, f_sum, 1);
        } else {
            addTexel(ivec2(-1, 0), pushedfragCurvature, f_sum, 3);
            addTexel(ivec2(0, +1), pushedfragCurvature, f_sum, 3);
            addTexel(ivec2(-1, +1), pushedfragCurvature, f_sum, 1);
        }
    } else {
        if (int(gl_FragCoord.y) % 2 == 0) {
            addTexel(ivec2(+1, 0), pushedfragCurvature, f_sum, 3);
            addTexel(ivec2(0, -1), pushedfragCurvature, f_sum, 3);
            addTexel(ivec2(+1, -1), pushedfragCurvature, f_sum, 1);
        } else {
            addTexel(ivec2(+1, 0), pushedfragCurvature, f_sum, 3);
            addTexel(ivec2(0, +1), pushedfragCurvature, f_sum, 3);
            addTexel(ivec2(+1, +1), pushedfragCurvature, f_sum, 1);
        }
    }

    if (isnan(pushedfragCurvature.y) || isinf(pushedfragCurvature.y) ) {
        pushedfragCurvature = vec4(0);
        return;
    }

    if (pushedfragCurvature.y != 0 && f_sum != 0) {
        pushedfragCurvature.w /= f_sum;
        pushedfragCurvature.y /= f_sum;
    } else {
        pushedfragCurvature.w = 0;
    }

    float alpha = originalfragCurvature.w;
        alpha = 1 - pow(1 - alpha, 1); // Eq. (7)
    pushedfragCurvature.w = min(1, pushedfragCurvature.w * (1 - alpha) + alpha);
    pushedfragCurvature.y = originalfragCurvature.y * alpha + pushedfragCurvature.y * (1 - alpha);
}

void main() {
    fragCurvature = vec4(0);
    push(fragCurvature);

    // auf y schauen, da noch keine Maske verwendet wird.
    fragCurvature.xyz = vec3(fragCurvature.y);
}

-->
            </snippet>
        </shader>

        <shader name="pullMaxDepth">
            <snippet type="version">430</snippet>
            <snippet name="::protein::commondefines"/>
            <snippet type="string">
<!--
out vec4 fragMaxDepth;

uniform int level;

uniform sampler2D inputTex_fragPosition;
uniform sampler2D pyramid_fragMaxDepth;


void pull(out vec4 pulledFragMaxDepth) {
    // read all finer pixels' values
    vec2 md_bl = (texelFetch(pyramid_fragMaxDepth, ivec2(gl_FragCoord.xy) * 2 + ivec2(0), level - 1)).xy;
    vec2 md_tl = (texelFetch(pyramid_fragMaxDepth, ivec2(gl_FragCoord.xy) * 2 + ivec2(0, 1), level - 1)).xy;
    vec2 md_tr = (texelFetch(pyramid_fragMaxDepth, ivec2(gl_FragCoord.xy) * 2 + ivec2(1), level - 1)).xy;
    vec2 md_br = (texelFetch(pyramid_fragMaxDepth, ivec2(gl_FragCoord.xy) * 2 + ivec2(1, 0), level - 1)).xy;
    float maximum = max(max(md_bl.x, md_tl.x), max(md_tr.x, md_br.x));
    float minimum = min(min(md_bl.y, md_tl.y), min(md_tr.y, md_br.y));
    pulledFragMaxDepth = vec4(maximum, minimum, 0.0, 0.0);
}

void main() {
    fragMaxDepth = vec4(0.0f);

    if (level == 0) {
        float depth = texelFetch(inputTex_fragPosition, ivec2(gl_FragCoord.xy), 0).z;
        fragMaxDepth = vec4(depth);
        return;
    }

    pull(fragMaxDepth);
}
-->
            </snippet>
        </shader>

        <shader name="pullSC">
            <snippet type="version">430</snippet>
            <snippet name="::protein::commondefines"/>
            <snippet type="string">
<!--
out vec4 outData;

uniform int level;
uniform sampler2D inputTex_fragNormal;
uniform sampler2D inputTex_fragPosition;
uniform sampler2D pyramid_outData;


void pull(out vec4 pulledOutData)
{
    // read all finer pixels' values
    vec4 bl = (texelFetch(pyramid_outData, ivec2(gl_FragCoord.xy) * 2 + ivec2(0), level-1));
    vec4 tl = (texelFetch(pyramid_outData, ivec2(gl_FragCoord.xy) * 2 + ivec2(0, 1), level-1));
    vec4 tr = (texelFetch(pyramid_outData, ivec2(gl_FragCoord.xy) * 2 + ivec2(1), level-1));
    vec4 br = (texelFetch(pyramid_outData, ivec2(gl_FragCoord.xy) * 2 + ivec2(1, 0), level-1));

    float col = min(min(bl.y, br.y), min(tl.y, tr.y)); // minimum
    pulledOutData = vec4(vec3(col), 1.0);
}

void main() {
    outData = vec4(0);

    if (level == 0) {
        vec3 fragNormal = (texelFetch(inputTex_fragNormal, ivec2(gl_FragCoord.xy), 0)).xyz;
        vec3 fragPosition = (texelFetch(inputTex_fragPosition, ivec2(gl_FragCoord.xy), 0)).xyz;
        vec3 lightDir = normalize(-fragPosition);
        float col = dot(fragNormal, lightDir);
        outData = vec4(col, col, col, 1.0);
    }
    else{
    pull(outData);
    }
}
-->
            </snippet>
        </shader>
        <shader name="pullMaxX">
            <snippet type="version">430</snippet>
            <snippet name="::protein::commondefines"/>
            <snippet type="string">
<!--
out vec4 fragMaxX;

uniform int level;

uniform sampler2D inputTex_fragPosition;
uniform sampler2D pyramid_fragMaxX;


void pull(out vec4 pulledFragMaxX) {
    // read all finer pixels' values
    vec2 md_bl = (texelFetch(pyramid_fragMaxX, ivec2(gl_FragCoord.xy) * 2 + ivec2(0), level - 1)).xy;
    vec2 md_tl = (texelFetch(pyramid_fragMaxX, ivec2(gl_FragCoord.xy) * 2 + ivec2(0, 1), level - 1)).xy;
    vec2 md_tr = (texelFetch(pyramid_fragMaxX, ivec2(gl_FragCoord.xy) * 2 + ivec2(1), level - 1)).xy;
    vec2 md_br = (texelFetch(pyramid_fragMaxX, ivec2(gl_FragCoord.xy) * 2 + ivec2(1, 0), level - 1)).xy;
    float maximum = max(max(md_bl.x, md_tl.x), max(md_tr.x, md_br.x));
    float minimum = min(min(md_bl.y, md_tl.y), min(md_tr.y, md_br.y));
    pulledFragMaxX = vec4(maximum, minimum, 0.0, 0.0);
}

void main() {
    fragMaxX = vec4(0.0f);

    if (level == 0) {
        float width = texelFetch(inputTex_fragPosition, ivec2(gl_FragCoord.xy), 0).x;
        fragMaxX = vec4(width);
        return;
    }

    pull(fragMaxX);
}
-->
            </snippet>
        </shader>
        <shader name="pullMaxY">
            <snippet type="version">430</snippet>
            <snippet name="::protein::commondefines"/>
            <snippet type="string">
<!--
out vec4 fragMaxY;

uniform int level;

uniform sampler2D inputTex_fragPosition;
uniform sampler2D pyramid_fragMaxY;


void pull(out vec4 pulledFragMaxY) {
    // read all finer pixels' values
    vec2 md_bl = (texelFetch(pyramid_fragMaxY, ivec2(gl_FragCoord.xy) * 2 + ivec2(0), level - 1)).xy;
    vec2 md_tl = (texelFetch(pyramid_fragMaxY, ivec2(gl_FragCoord.xy) * 2 + ivec2(0, 1), level - 1)).xy;
    vec2 md_tr = (texelFetch(pyramid_fragMaxY, ivec2(gl_FragCoord.xy) * 2 + ivec2(1), level - 1)).xy;
    vec2 md_br = (texelFetch(pyramid_fragMaxY, ivec2(gl_FragCoord.xy) * 2 + ivec2(1, 0), level - 1)).xy;
    float maximum = max(max(md_bl.x, md_tl.x), max(md_tr.x, md_br.x));
    float minimum = min(min(md_bl.y, md_tl.y), min(md_tr.y, md_br.y));
    pulledFragMaxY = vec4(maximum, minimum, 0.0, 0.0);
}

void main() {
    fragMaxY = vec4(0.0f);

    if (level == 0) {
        float height = texelFetch(inputTex_fragPosition, ivec2(gl_FragCoord.xy), 0).y;
        fragMaxY = vec4(height);
        return;
    }

    pull(fragMaxY);
}

-->
            </snippet>
        </shader>

        <shader name="pushSC">
            <snippet type="version">430</snippet>
            <snippet name="::protein::commondefines"/>
            <snippet type="string">
<!--
out vec4 outData;

uniform sampler2D pyramid_outData;

uniform float lf;
uniform int level;
uniform float intensityDiffThreshold;

void addTexel(ivec2 offset, inout vec4 pushedOutData)
{
    ivec2 c = offset + ivec2(gl_FragCoord.xy / 2);
    int max_coord = int(0.5/lf - 1);
    if (c.x < 0 || c.y < 0 || c.x > max_coord || c.y > max_coord)
    return;

    vec4 n = (texelFetch(pyramid_outData, c, level + 1));

    if (any(isnan(n)) || any(isinf(n))) {
        return;
    }
    float col = min(pushedOutData.x,  n.x);
    pushedOutData.xyz = vec3(col);
}

void push(out vec4 pushedOutData)
{
    float f_sum = 0;


    pushedOutData = texelFetch(pyramid_outData, ivec2(gl_FragCoord.xy/2), level + 1);
    if (int(gl_FragCoord.x) % 2 == 0) {
        if (int(gl_FragCoord.y) % 2 == 0) {
            addTexel(ivec2(-1, 0), pushedOutData);
            addTexel(ivec2(0, -1), pushedOutData);
            addTexel(ivec2(-1, -1), pushedOutData);
        } else {
            addTexel(ivec2(-1, 0), pushedOutData);
            addTexel(ivec2(0, +1), pushedOutData);
            addTexel(ivec2(-1, +1), pushedOutData);
        }
    } else {
        if (int(gl_FragCoord.y) % 2 == 0) {
            addTexel(ivec2(+1, 0), pushedOutData);
            addTexel(ivec2(0, -1), pushedOutData);
            addTexel(ivec2(+1, -1), pushedOutData);
        } else {
            addTexel(ivec2(+1, 0), pushedOutData);
            addTexel(ivec2(0, +1), pushedOutData);
            addTexel(ivec2(+1, +1), pushedOutData);
        }
    }

    if (any(isnan(pushedOutData.xyz)) || any(isinf(pushedOutData.xyz)) ) {
        return;
    }
}

void main() {
    outData = vec4(0);
    push(outData);
    if(level == 0){
        vec4 originalData = texelFetch(pyramid_outData, ivec2(gl_FragCoord.xy), level);
        if(originalData.x  * intensityDiffThreshold <= outData.x){
            outData.xyz = vec3(0.8863, 0.8824, 0.6196);
        }
        else{
            outData.xyz = vec3(0.0118, 0.0118, 0.2745);
    
        }
        outData.w = 1.0;
    }
}

-->
            </snippet>
        </shader>
</btf>
